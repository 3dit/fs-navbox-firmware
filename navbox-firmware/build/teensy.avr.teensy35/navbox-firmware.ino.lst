
C:\Users\scott\AppData\Local\arduino\sketches\16E5215AE8E13E23123A9C6C702F0DC0/navbox-firmware.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
{
  VA1State = digitalRead(A1Input);
}

void doChangeA2()
{
       0:	f8 ff 02 20 99 01 00 00 81 10 00 00 3d 10 00 00     ... ........=...
  VA2State = digitalRead(A2Input) << 1;
      10:	3d 10 00 00 3d 10 00 00 3d 10 00 00 3d 10 00 00     =...=...=...=...
size_t Print::printFloat(double number, uint8_t digits) 
{
	uint8_t sign=0;
	size_t count=0;

	if (isnan(number)) return print("nan");
      20:	3d 10 00 00 3d 10 00 00 3d 10 00 00 81 10 00 00     =...=...=.......
    	if (isinf(number)) return print("inf");
      30:	81 10 00 00 3d 10 00 00 6d 22 00 00 71 22 00 00     ....=...m"..q"..
      40:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
    	if (number > 4294967040.0f) return print("ovf");  // constant determined empirically
      50:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
    	if (number <-4294967040.0f) return print("ovf");  // constant determined empirically
      60:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
	
	// Handle negative numbers
	if (number < 0.0) {
      70:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
	uint8_t sign=0;
      80:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
		number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i) {
      90:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
		rounding *= 0.1;
      a0:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
	}
	number += rounding;
      b0:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
      c0:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
	double remainder = number - (double)int_part;
      d0:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
      e0:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
	count += printNumber(int_part, 10, sign);

	// Print the decimal point, but only if there are digits beyond
	if (digits > 0) {
		uint8_t n, buf[16], count=1;
		buf[0] = '.';
      f0:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
     100:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
			remainder *= 10.0;
     110:	81 10 00 00 75 14 00 00 81 10 00 00 81 10 00 00     ....u...........
			n = (uint8_t)(remainder);
			buf[count++] = '0' + n;
     120:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
			remainder -= n; 
     130:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
			buf[count++] = '0' + n;
     140:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
		}
		count += write(buf, count);
	}
	return count;
}
     150:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
     160:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
		number = -number;
     170:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
	number += rounding;
     180:	81 10 00 00 81 10 00 00 81 10 00 00 81 10 00 00     ................
	unsigned long int_part = (unsigned long)number;
     190:	81 10 00 00 81 10 00 00                             ........

00000198 <ResetHandler>:
}
     198:	4b5a      	ldr	r3, [pc, #360]	; (304 <ResetHandler+0x16c>)
     19a:	f24c 5220 	movw	r2, #50464	; 0xc520
     19e:	b510      	push	{r4, lr}
     1a0:	81da      	strh	r2, [r3, #14]
     1a2:	f64d 1228 	movw	r2, #55592	; 0xd928
     1a6:	81da      	strh	r2, [r3, #14]
     1a8:	bf00      	nop
     1aa:	bf00      	nop
     1ac:	f000 ff6c 	bl	1088 <startup_early_hook>
     1b0:	4b55      	ldr	r3, [pc, #340]	; (308 <ResetHandler+0x170>)
     1b2:	f04f 6230 	mov.w	r2, #184549376	; 0xb000000
     1b6:	631a      	str	r2, [r3, #48]	; 0x30
     1b8:	4a54      	ldr	r2, [pc, #336]	; (30c <ResetHandler+0x174>)
     1ba:	639a      	str	r2, [r3, #56]	; 0x38
     1bc:	4a54      	ldr	r2, [pc, #336]	; (310 <ResetHandler+0x178>)
     1be:	63da      	str	r2, [r3, #60]	; 0x3c
     1c0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     1c4:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1c8:	f8c3 2d88 	str.w	r2, [r3, #3464]	; 0xd88
#endif
#if defined(KINETISK) && !defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started early.
	// But don't do this early on Teensy 3.6 - RTC_CR depends on 3.3V+VBAT
	// which may be ~0.4V "behind" 3.3V if the power ramps up slowly.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     1cc:	4a51      	ldr	r2, [pc, #324]	; (314 <ResetHandler+0x17c>)
     1ce:	6913      	ldr	r3, [r2, #16]
     1d0:	f413 7380 	ands.w	r3, r3, #256	; 0x100
     1d4:	d103      	bne.n	1de <ResetHandler+0x46>
		RTC_SR = 0;
     1d6:	6153      	str	r3, [r2, #20]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     1d8:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     1dc:	6113      	str	r3, [r2, #16]
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     1de:	4b4e      	ldr	r3, [pc, #312]	; (318 <ResetHandler+0x180>)
     1e0:	789a      	ldrb	r2, [r3, #2]
     1e2:	0711      	lsls	r1, r2, #28
     1e4:	d503      	bpl.n	1ee <ResetHandler+0x56>
     1e6:	789a      	ldrb	r2, [r3, #2]
     1e8:	f042 0208 	orr.w	r2, r2, #8
     1ec:	709a      	strb	r2, [r3, #2]
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     1ee:	4b4b      	ldr	r3, [pc, #300]	; (31c <ResetHandler+0x184>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1f0:	484b      	ldr	r0, [pc, #300]	; (320 <ResetHandler+0x188>)
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     1f2:	222a      	movs	r2, #42	; 0x2a
     1f4:	701a      	strb	r2, [r3, #0]
	while (dest < &_edata) *dest++ = *src++;
     1f6:	4b4b      	ldr	r3, [pc, #300]	; (324 <ResetHandler+0x18c>)
     1f8:	1cda      	adds	r2, r3, #3
     1fa:	1a12      	subs	r2, r2, r0
     1fc:	1ec1      	subs	r1, r0, #3
     1fe:	f022 0203 	bic.w	r2, r2, #3
     202:	4299      	cmp	r1, r3
     204:	bf88      	it	hi
     206:	2200      	movhi	r2, #0
     208:	4947      	ldr	r1, [pc, #284]	; (328 <ResetHandler+0x190>)
     20a:	f000 fe43 	bl	e94 <memcpy>
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     20e:	4b47      	ldr	r3, [pc, #284]	; (32c <ResetHandler+0x194>)
     210:	4847      	ldr	r0, [pc, #284]	; (330 <ResetHandler+0x198>)
     212:	1cda      	adds	r2, r3, #3
     214:	1a12      	subs	r2, r2, r0
     216:	1ec1      	subs	r1, r0, #3
     218:	f022 0203 	bic.w	r2, r2, #3
     21c:	4299      	cmp	r1, r3
     21e:	bf88      	it	hi
     220:	2200      	movhi	r2, #0
     222:	2100      	movs	r1, #0
     224:	f002 f8ca 	bl	23bc <memset>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     228:	4942      	ldr	r1, [pc, #264]	; (334 <ResetHandler+0x19c>)
     22a:	4843      	ldr	r0, [pc, #268]	; (338 <ResetHandler+0x1a0>)
     22c:	f44f 72cc 	mov.w	r2, #408	; 0x198
     230:	f000 fe30 	bl	e94 <memcpy>
     234:	4b41      	ldr	r3, [pc, #260]	; (33c <ResetHandler+0x1a4>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     236:	4a42      	ldr	r2, [pc, #264]	; (340 <ResetHandler+0x1a8>)
     238:	2180      	movs	r1, #128	; 0x80
     23a:	f803 1b01 	strb.w	r1, [r3], #1
     23e:	4293      	cmp	r3, r2
     240:	d1fb      	bne.n	23a <ResetHandler+0xa2>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     242:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     246:	4a3c      	ldr	r2, [pc, #240]	; (338 <ResetHandler+0x1a0>)
     248:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     24c:	4b3d      	ldr	r3, [pc, #244]	; (344 <ResetHandler+0x1ac>)
     24e:	228a      	movs	r2, #138	; 0x8a
     250:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     252:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     256:	2224      	movs	r2, #36	; 0x24
     258:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     25a:	22a0      	movs	r2, #160	; 0xa0
     25c:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     25e:	799a      	ldrb	r2, [r3, #6]
     260:	0792      	lsls	r2, r2, #30
     262:	d5fc      	bpl.n	25e <ResetHandler+0xc6>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     264:	799a      	ldrb	r2, [r3, #6]
     266:	06d4      	lsls	r4, r2, #27
     268:	d4fc      	bmi.n	264 <ResetHandler+0xcc>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     26a:	4b37      	ldr	r3, [pc, #220]	; (348 <ResetHandler+0x1b0>)
     26c:	799a      	ldrb	r2, [r3, #6]
     26e:	f002 020c 	and.w	r2, r2, #12
     272:	2a08      	cmp	r2, #8
     274:	d1fa      	bne.n	26c <ResetHandler+0xd4>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
     276:	2203      	movs	r2, #3
     278:	711a      	strb	r2, [r3, #4]
    #if F_CPU == 168000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(18); // config PLL for 168 MHz output
    #elif F_CPU == 144000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(12); // config PLL for 144 MHz output
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
     27a:	2246      	movs	r2, #70	; 0x46
     27c:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     27e:	799a      	ldrb	r2, [r3, #6]
     280:	0690      	lsls	r0, r2, #26
     282:	d5fc      	bpl.n	27e <ResetHandler+0xe6>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     284:	4a30      	ldr	r2, [pc, #192]	; (348 <ResetHandler+0x1b0>)
     286:	7993      	ldrb	r3, [r2, #6]
     288:	0659      	lsls	r1, r3, #25
     28a:	d5fc      	bpl.n	286 <ResetHandler+0xee>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(2);
#elif F_CPU == 120000000
	// config divisors: 120 MHz core, 60 MHz bus, 24 MHz flash, USB = 128 * 2 / 5
	#if F_BUS == 60000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(4);
     28c:	4b1e      	ldr	r3, [pc, #120]	; (308 <ResetHandler+0x170>)
     28e:	f04f 7182 	mov.w	r1, #17039360	; 0x1040000
     292:	6459      	str	r1, [r3, #68]	; 0x44
	#elif F_BUS == 120000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(4);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
     294:	2109      	movs	r1, #9
     296:	6499      	str	r1, [r3, #72]	; 0x48
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     298:	2120      	movs	r1, #32
     29a:	7011      	strb	r1, [r2, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     29c:	7991      	ldrb	r1, [r2, #6]
     29e:	f001 010c 	and.w	r1, r1, #12
     2a2:	290c      	cmp	r1, #12
     2a4:	d1fa      	bne.n	29c <ResetHandler+0x104>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2a6:	4a29      	ldr	r2, [pc, #164]	; (34c <ResetHandler+0x1b4>)
     2a8:	605a      	str	r2, [r3, #4]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2aa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     2ae:	4a28      	ldr	r2, [pc, #160]	; (350 <ResetHandler+0x1b8>)
     2b0:	615a      	str	r2, [r3, #20]
	SYST_CVR = 0;
     2b2:	2200      	movs	r2, #0
     2b4:	619a      	str	r2, [r3, #24]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2b6:	2207      	movs	r2, #7
     2b8:	611a      	str	r2, [r3, #16]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ba:	4a26      	ldr	r2, [pc, #152]	; (354 <ResetHandler+0x1bc>)
     2bc:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20

	//init_pins();
	__enable_irq();
     2c0:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     2c2:	f000 ff23 	bl	110c <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2c6:	4b13      	ldr	r3, [pc, #76]	; (314 <ResetHandler+0x17c>)
     2c8:	695b      	ldr	r3, [r3, #20]
     2ca:	07da      	lsls	r2, r3, #31
     2cc:	d505      	bpl.n	2da <ResetHandler+0x142>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2ce:	4822      	ldr	r0, [pc, #136]	; (358 <ResetHandler+0x1c0>)
     2d0:	f000 ff10 	bl	10f4 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     2d4:	4b21      	ldr	r3, [pc, #132]	; (35c <ResetHandler+0x1c4>)
     2d6:	4a22      	ldr	r2, [pc, #136]	; (360 <ResetHandler+0x1c8>)
     2d8:	61da      	str	r2, [r3, #28]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     2da:	4b22      	ldr	r3, [pc, #136]	; (364 <ResetHandler+0x1cc>)
     2dc:	781b      	ldrb	r3, [r3, #0]
     2de:	065b      	lsls	r3, r3, #25
     2e0:	d509      	bpl.n	2f6 <ResetHandler+0x15e>
     2e2:	4c1e      	ldr	r4, [pc, #120]	; (35c <ResetHandler+0x1c4>)
     2e4:	4b1e      	ldr	r3, [pc, #120]	; (360 <ResetHandler+0x1c8>)
     2e6:	69e2      	ldr	r2, [r4, #28]
     2e8:	429a      	cmp	r2, r3
     2ea:	d104      	bne.n	2f6 <ResetHandler+0x15e>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2ec:	481a      	ldr	r0, [pc, #104]	; (358 <ResetHandler+0x1c0>)
     2ee:	f000 ff01 	bl	10f4 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     2f2:	2300      	movs	r3, #0
     2f4:	61e3      	str	r3, [r4, #28]
	}
#endif

	startup_late_hook();
     2f6:	f000 fecd 	bl	1094 <startup_late_hook>
	__libc_init_array();
     2fa:	f002 f8b1 	bl	2460 <__libc_init_array>

	main();
     2fe:	f000 fdc1 	bl	e84 <main>
	
	while (1) ;
     302:	e7fe      	b.n	302 <ResetHandler+0x16a>
     304:	40052000 	.word	0x40052000
     308:	40048000 	.word	0x40048000
     30c:	00043f82 	.word	0x00043f82
     310:	2b000001 	.word	0x2b000001
     314:	4003d000 	.word	0x4003d000
     318:	4007d000 	.word	0x4007d000
     31c:	4007e000 	.word	0x4007e000
     320:	1fff0938 	.word	0x1fff0938
     324:	1fff0b50 	.word	0x1fff0b50
     328:	0000288c 	.word	0x0000288c
     32c:	1fff0ee0 	.word	0x1fff0ee0
     330:	1fff0b50 	.word	0x1fff0b50
     334:	00000000 	.word	0x00000000
     338:	1fff0200 	.word	0x1fff0200
     33c:	e000e400 	.word	0xe000e400
     340:	e000e456 	.word	0xe000e456
     344:	40065000 	.word	0x40065000
     348:	40064000 	.word	0x40064000
     34c:	000510c0 	.word	0x000510c0
     350:	0001d4bf 	.word	0x0001d4bf
     354:	20200000 	.word	0x20200000
     358:	68e11848 	.word	0x68e11848
     35c:	4003e000 	.word	0x4003e000
     360:	5a94c3a5 	.word	0x5a94c3a5
     364:	4007f000 	.word	0x4007f000
     368:	ffffffff 	.word	0xffffffff
     36c:	ffffffff 	.word	0xffffffff
     370:	ffffffff 	.word	0xffffffff
     374:	ffffffff 	.word	0xffffffff
     378:	ffffffff 	.word	0xffffffff
     37c:	ffffffff 	.word	0xffffffff
     380:	ffffffff 	.word	0xffffffff
     384:	ffffffff 	.word	0xffffffff
     388:	ffffffff 	.word	0xffffffff
     38c:	ffffffff 	.word	0xffffffff
     390:	ffffffff 	.word	0xffffffff
     394:	ffffffff 	.word	0xffffffff
     398:	ffffffff 	.word	0xffffffff
     39c:	ffffffff 	.word	0xffffffff
     3a0:	ffffffff 	.word	0xffffffff
     3a4:	ffffffff 	.word	0xffffffff
     3a8:	ffffffff 	.word	0xffffffff
     3ac:	ffffffff 	.word	0xffffffff
     3b0:	ffffffff 	.word	0xffffffff
     3b4:	ffffffff 	.word	0xffffffff
     3b8:	ffffffff 	.word	0xffffffff
     3bc:	ffffffff 	.word	0xffffffff
     3c0:	ffffffff 	.word	0xffffffff
     3c4:	ffffffff 	.word	0xffffffff
     3c8:	ffffffff 	.word	0xffffffff
     3cc:	ffffffff 	.word	0xffffffff
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <register_tm_clones>:
     410:	4805      	ldr	r0, [pc, #20]	; (428 <register_tm_clones+0x18>)
     412:	4b06      	ldr	r3, [pc, #24]	; (42c <register_tm_clones+0x1c>)
     414:	1a1b      	subs	r3, r3, r0
     416:	0fd9      	lsrs	r1, r3, #31
     418:	eb01 01a3 	add.w	r1, r1, r3, asr #2
     41c:	1049      	asrs	r1, r1, #1
     41e:	d002      	beq.n	426 <register_tm_clones+0x16>
     420:	4b03      	ldr	r3, [pc, #12]	; (430 <register_tm_clones+0x20>)
     422:	b103      	cbz	r3, 426 <register_tm_clones+0x16>
     424:	4718      	bx	r3
     426:	4770      	bx	lr
     428:	1fff0b50 	.word	0x1fff0b50
     42c:	1fff0b50 	.word	0x1fff0b50
     430:	00000000 	.word	0x00000000

00000434 <frame_dummy>:
     434:	b508      	push	{r3, lr}
     436:	4b05      	ldr	r3, [pc, #20]	; (44c <frame_dummy+0x18>)
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4905      	ldr	r1, [pc, #20]	; (450 <frame_dummy+0x1c>)
     43c:	4805      	ldr	r0, [pc, #20]	; (454 <frame_dummy+0x20>)
     43e:	f3af 8000 	nop.w
     442:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     446:	f7ff bfe3 	b.w	410 <register_tm_clones>
     44a:	bf00      	nop
     44c:	00000000 	.word	0x00000000
     450:	1fff0b50 	.word	0x1fff0b50
     454:	0000288c 	.word	0x0000288c

00000458 <setup>:
void setup() {
     458:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
class usb_seremu_class : public Stream
{
public:
	constexpr usb_seremu_class() {}
        void begin(long) {
		uint32_t millis_begin = systick_millis_count;
     45c:	4d30      	ldr	r5, [pc, #192]	; (520 <setup+0xc8>)
     45e:	4c31      	ldr	r4, [pc, #196]	; (524 <setup+0xcc>)
     460:	682e      	ldr	r6, [r5, #0]
        uint8_t stopbits(void) { return 1; }
        uint8_t paritytype(void) { return 0; }
        uint8_t numbits(void) { return 8; }
        uint8_t dtr(void) { return 1; }
        uint8_t rts(void) { return 1; }
        operator bool() { yield(); return usb_configuration && usb_seremu_online; }
     462:	4f31      	ldr	r7, [pc, #196]	; (528 <setup+0xd0>)
				if (elapsed > 750) break;
     464:	f240 28ee 	movw	r8, #750	; 0x2ee
        operator bool() { yield(); return usb_configuration && usb_seremu_online; }
     468:	f001 fe66 	bl	2138 <yield>
     46c:	7823      	ldrb	r3, [r4, #0]
     46e:	2b00      	cmp	r3, #0
     470:	d048      	beq.n	504 <setup+0xac>
     472:	783b      	ldrb	r3, [r7, #0]
     474:	2b00      	cmp	r3, #0
     476:	d045      	beq.n	504 <setup+0xac>
		}
		if (!manual_mode) usb_joystick_send();
        }
#endif
	void useManualSend(bool mode) {
		manual_mode = mode;
     478:	4b2c      	ldr	r3, [pc, #176]	; (52c <setup+0xd4>)
     47a:	2201      	movs	r2, #1
     47c:	701a      	strb	r2, [r3, #0]
  for (int i = 0; i < numButtons; i++) {
     47e:	2400      	movs	r4, #0
    pinMode(i, INPUT_PULLUP);
     480:	b2e0      	uxtb	r0, r4
     482:	2102      	movs	r1, #2
  for (int i = 0; i < numButtons; i++) {
     484:	3401      	adds	r4, #1
    pinMode(i, INPUT_PULLUP);
     486:	f000 feb1 	bl	11ec <pinMode>
  for (int i = 0; i < numButtons; i++) {
     48a:	2c1c      	cmp	r4, #28
     48c:	d1f8      	bne.n	480 <setup+0x28>
  pinMode(A1Input, INPUT_PULLUP);
     48e:	4b28      	ldr	r3, [pc, #160]	; (530 <setup+0xd8>)
     490:	2102      	movs	r1, #2
     492:	7818      	ldrb	r0, [r3, #0]
     494:	f000 feaa 	bl	11ec <pinMode>
  pinMode(A2Input, INPUT_PULLUP);
     498:	4b26      	ldr	r3, [pc, #152]	; (534 <setup+0xdc>)
     49a:	2102      	movs	r1, #2
     49c:	7818      	ldrb	r0, [r3, #0]
     49e:	f000 fea5 	bl	11ec <pinMode>
  pinMode(B1Input, INPUT_PULLUP);
     4a2:	4b25      	ldr	r3, [pc, #148]	; (538 <setup+0xe0>)
     4a4:	2102      	movs	r1, #2
     4a6:	7818      	ldrb	r0, [r3, #0]
     4a8:	f000 fea0 	bl	11ec <pinMode>
  pinMode(B2Input, INPUT_PULLUP);
     4ac:	4b23      	ldr	r3, [pc, #140]	; (53c <setup+0xe4>)
     4ae:	2102      	movs	r1, #2
     4b0:	7818      	ldrb	r0, [r3, #0]
     4b2:	f000 fe9b 	bl	11ec <pinMode>
  pinMode(C1Input, INPUT_PULLUP);
     4b6:	4b22      	ldr	r3, [pc, #136]	; (540 <setup+0xe8>)
     4b8:	2102      	movs	r1, #2
     4ba:	7818      	ldrb	r0, [r3, #0]
     4bc:	f000 fe96 	bl	11ec <pinMode>
  pinMode(C2Input, INPUT_PULLUP);
     4c0:	4b20      	ldr	r3, [pc, #128]	; (544 <setup+0xec>)
     4c2:	2102      	movs	r1, #2
     4c4:	7818      	ldrb	r0, [r3, #0]
     4c6:	f000 fe91 	bl	11ec <pinMode>
  pinMode(D1Input, INPUT_PULLUP);
     4ca:	4b1f      	ldr	r3, [pc, #124]	; (548 <setup+0xf0>)
     4cc:	2102      	movs	r1, #2
     4ce:	7818      	ldrb	r0, [r3, #0]
     4d0:	f000 fe8c 	bl	11ec <pinMode>
  pinMode(D2Input, INPUT_PULLUP);
     4d4:	4b1d      	ldr	r3, [pc, #116]	; (54c <setup+0xf4>)
     4d6:	2102      	movs	r1, #2
     4d8:	7818      	ldrb	r0, [r3, #0]
     4da:	f000 fe87 	bl	11ec <pinMode>
  pinMode(E1Input, INPUT_PULLUP);
     4de:	4b1c      	ldr	r3, [pc, #112]	; (550 <setup+0xf8>)
     4e0:	2102      	movs	r1, #2
     4e2:	7818      	ldrb	r0, [r3, #0]
     4e4:	f000 fe82 	bl	11ec <pinMode>
  pinMode(E2Input, INPUT_PULLUP);
     4e8:	4b1a      	ldr	r3, [pc, #104]	; (554 <setup+0xfc>)
     4ea:	2102      	movs	r1, #2
     4ec:	7818      	ldrb	r0, [r3, #0]
     4ee:	f000 fe7d 	bl	11ec <pinMode>
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     4f2:	4621      	mov	r1, r4
     4f4:	4818      	ldr	r0, [pc, #96]	; (558 <setup+0x100>)
     4f6:	f001 fd25 	bl	1f44 <usb_seremu_write>
}
     4fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     4fe:	4817      	ldr	r0, [pc, #92]	; (55c <setup+0x104>)
     500:	f000 bcb2 	b.w	e68 <Print::println()>
			uint32_t elapsed = systick_millis_count - millis_begin;
     504:	682b      	ldr	r3, [r5, #0]
			if (usb_configuration) {
     506:	7822      	ldrb	r2, [r4, #0]
			uint32_t elapsed = systick_millis_count - millis_begin;
     508:	1b9b      	subs	r3, r3, r6
			if (usb_configuration) {
     50a:	b12a      	cbz	r2, 518 <setup+0xc0>
				if (elapsed > 2000) break;
     50c:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
     510:	d8b2      	bhi.n	478 <setup+0x20>
			yield();
     512:	f001 fe11 	bl	2138 <yield>
     516:	e7a7      	b.n	468 <setup+0x10>
				if (elapsed > 750) break;
     518:	4543      	cmp	r3, r8
     51a:	d9fa      	bls.n	512 <setup+0xba>
     51c:	e7ac      	b.n	478 <setup+0x20>
     51e:	bf00      	nop
     520:	1fff0bf0 	.word	0x1fff0bf0
     524:	1fff0ce1 	.word	0x1fff0ce1
     528:	1fff0d14 	.word	0x1fff0d14
     52c:	1fff0cf9 	.word	0x1fff0cf9
     530:	1fff0b68 	.word	0x1fff0b68
     534:	1fff0938 	.word	0x1fff0938
     538:	1fff0950 	.word	0x1fff0950
     53c:	1fff0951 	.word	0x1fff0951
     540:	1fff096c 	.word	0x1fff096c
     544:	1fff096d 	.word	0x1fff096d
     548:	1fff0984 	.word	0x1fff0984
     54c:	1fff0985 	.word	0x1fff0985
     550:	1fff099c 	.word	0x1fff099c
     554:	1fff099d 	.word	0x1fff099d
     558:	00002580 	.word	0x00002580
     55c:	1fff09b8 	.word	0x1fff09b8

00000560 <encoderA()>:
  //}

  delay(1);
}

void encoderA() {
     560:	b5f0      	push	{r4, r5, r6, r7, lr}
     562:	b083      	sub	sp, #12
  // read the input pin:
  cli();
     564:	b672      	cpsid	i
  //A1State = VA1State; //digitalRead(A1Input);
  //A2State = VA2State; //digitalRead(A2Input) << 1;
  sei();
     566:	b662      	cpsie	i
  A1State = digitalRead(A1Input);
     568:	4b62      	ldr	r3, [pc, #392]	; (6f4 <encoderA()+0x194>)
     56a:	4c63      	ldr	r4, [pc, #396]	; (6f8 <encoderA()+0x198>)
     56c:	7818      	ldrb	r0, [r3, #0]
     56e:	f000 fe2f 	bl	11d0 <digitalRead>
  A2State = digitalRead(A2Input) << 1;
     572:	4b62      	ldr	r3, [pc, #392]	; (6fc <encoderA()+0x19c>)
  A1State = digitalRead(A1Input);
     574:	7020      	strb	r0, [r4, #0]
  A2State = digitalRead(A2Input) << 1;
     576:	7818      	ldrb	r0, [r3, #0]
     578:	f000 fe2a 	bl	11d0 <digitalRead>

  AState = A1State | A2State;
     57c:	7823      	ldrb	r3, [r4, #0]
     57e:	4a60      	ldr	r2, [pc, #384]	; (700 <encoderA()+0x1a0>)
  int currentRotateResetDelay = ARotateResetDelay;

  //AMinimumMsForExtendedMove = 50;
  //AExtendedMoveMs = 200;

  if (lastStateA != AState) {
     580:	4c60      	ldr	r4, [pc, #384]	; (704 <encoderA()+0x1a4>)
  A2State = digitalRead(A2Input) << 1;
     582:	4961      	ldr	r1, [pc, #388]	; (708 <encoderA()+0x1a8>)
     584:	0040      	lsls	r0, r0, #1
     586:	b2c0      	uxtb	r0, r0
  AState = A1State | A2State;
     588:	4303      	orrs	r3, r0
     58a:	7013      	strb	r3, [r2, #0]
  if (lastStateA != AState) {
     58c:	7822      	ldrb	r2, [r4, #0]
  A2State = digitalRead(A2Input) << 1;
     58e:	7008      	strb	r0, [r1, #0]
  int currentRotateResetDelay = ARotateResetDelay;
     590:	495e      	ldr	r1, [pc, #376]	; (70c <encoderA()+0x1ac>)
  if (lastStateA != AState) {
     592:	4293      	cmp	r3, r2
  int currentRotateResetDelay = ARotateResetDelay;
     594:	6808      	ldr	r0, [r1, #0]
  if (lastStateA != AState) {
     596:	d016      	beq.n	5c6 <encoderA()+0x66>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     598:	4e5d      	ldr	r6, [pc, #372]	; (710 <encoderA()+0x1b0>)

    //state has changed, is it close enough to last time that we have to extend 'on' time?
    unsigned int nowms = millis();
    if (ALastTickTime > nowms)
     59a:	4d5e      	ldr	r5, [pc, #376]	; (714 <encoderA()+0x1b4>)
     59c:	6831      	ldr	r1, [r6, #0]
     59e:	9100      	str	r1, [sp, #0]
	return ret;
     5a0:	9900      	ldr	r1, [sp, #0]
     5a2:	682f      	ldr	r7, [r5, #0]
     5a4:	428f      	cmp	r7, r1
     5a6:	d949      	bls.n	63c <encoderA()+0xdc>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     5a8:	6831      	ldr	r1, [r6, #0]
     5aa:	9101      	str	r1, [sp, #4]
	return ret;
     5ac:	9901      	ldr	r1, [sp, #4]
      {
        isExtendedMove = true;
        currentRotateResetDelay = AExtendedMoveMs;
      }
    }
    ALastTickTime = millis();
     5ae:	6029      	str	r1, [r5, #0]


    switch (AState) {
     5b0:	2b03      	cmp	r3, #3
     5b2:	d808      	bhi.n	5c6 <encoderA()+0x66>
     5b4:	e8df f003 	tbb	[pc, r3]
     5b8:	02662255 	.word	0x02662255
          //ADialMoveRight = false;
          ADialMoveLeft = true;
        }
        break;
      case 3:
        if (lastStateA == 1) {
     5bc:	2a01      	cmp	r2, #1
     5be:	f000 8082 	beq.w	6c6 <encoderA()+0x166>
          stepsA++;
          cwA = 1;
          ADialMoveRight = true;
          //ADialMoveLeft = false;
        }
        else if (lastStateA == 2) {
     5c2:	2a02      	cmp	r2, #2
     5c4:	d062      	beq.n	68c <encoderA()+0x12c>
  //Serial.print(cwA);
  //Serial.print("\t");
  //Serial.println(stepsA);


  if (ADialMoveRight == true)
     5c6:	4a54      	ldr	r2, [pc, #336]	; (718 <encoderA()+0x1b8>)
     5c8:	4954      	ldr	r1, [pc, #336]	; (71c <encoderA()+0x1bc>)
     5ca:	7815      	ldrb	r5, [r2, #0]
  lastStateA = AState;
     5cc:	7023      	strb	r3, [r4, #0]
  if (ADialMoveRight == true)
     5ce:	bb0d      	cbnz	r5, 614 <encoderA()+0xb4>
    allButtons[ARotateRightButton] = 1;
    ADialMoveRight = false;
    ADialMoveLeft = false;
    ARightFalseCount = currentRotateResetDelay;
  } else {
    if (ARightFalseCount != -1) {
     5d0:	4c53      	ldr	r4, [pc, #332]	; (720 <encoderA()+0x1c0>)
     5d2:	6823      	ldr	r3, [r4, #0]
     5d4:	1c5d      	adds	r5, r3, #1
     5d6:	d037      	beq.n	648 <encoderA()+0xe8>
      ARightFalseCount--;
     5d8:	3b01      	subs	r3, #1
    }
    if (ARightFalseCount <= 0) {
     5da:	2b00      	cmp	r3, #0
      ARightFalseCount--;
     5dc:	6023      	str	r3, [r4, #0]
    if (ARightFalseCount <= 0) {
     5de:	dd33      	ble.n	648 <encoderA()+0xe8>
      allButtons[ARotateRightButton] = 0;
    }
  }
  if (ADialMoveLeft == true)
     5e0:	780b      	ldrb	r3, [r1, #0]
     5e2:	b30b      	cbz	r3, 628 <encoderA()+0xc8>
  {
    allButtons[ARotateLeftButton] = 1;
     5e4:	4b4f      	ldr	r3, [pc, #316]	; (724 <encoderA()+0x1c4>)
     5e6:	4d50      	ldr	r5, [pc, #320]	; (728 <encoderA()+0x1c8>)
     5e8:	681c      	ldr	r4, [r3, #0]
    ADialMoveLeft = false;
    ADialMoveRight = false;
    ALeftFalseCount = currentRotateResetDelay;
     5ea:	4b50      	ldr	r3, [pc, #320]	; (72c <encoderA()+0x1cc>)
     5ec:	6018      	str	r0, [r3, #0]
    ADialMoveLeft = false;
     5ee:	2300      	movs	r3, #0
     5f0:	700b      	strb	r3, [r1, #0]
    ADialMoveRight = false;
     5f2:	7013      	strb	r3, [r2, #0]
    allButtons[ARotateLeftButton] = 1;
     5f4:	2301      	movs	r3, #1
     5f6:	552b      	strb	r3, [r5, r4]
    if (ALeftFalseCount <= 0) {
      allButtons[ARotateLeftButton] = 0;
    }
  }

}
     5f8:	b003      	add	sp, #12
     5fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (lastStateA == 0) {
     5fc:	2a00      	cmp	r2, #0
     5fe:	d153      	bne.n	6a8 <encoderA()+0x148>
          stepsA++;
     600:	4a4b      	ldr	r2, [pc, #300]	; (730 <encoderA()+0x1d0>)
          cwA = 1;
     602:	494c      	ldr	r1, [pc, #304]	; (734 <encoderA()+0x1d4>)
          stepsA++;
     604:	7813      	ldrb	r3, [r2, #0]
     606:	3301      	adds	r3, #1
     608:	7013      	strb	r3, [r2, #0]
          cwA = 1;
     60a:	2301      	movs	r3, #1
     60c:	600b      	str	r3, [r1, #0]
  lastStateA = AState;
     60e:	4a42      	ldr	r2, [pc, #264]	; (718 <encoderA()+0x1b8>)
     610:	4942      	ldr	r1, [pc, #264]	; (71c <encoderA()+0x1bc>)
     612:	7023      	strb	r3, [r4, #0]
    allButtons[ARotateRightButton] = 1;
     614:	4b48      	ldr	r3, [pc, #288]	; (738 <encoderA()+0x1d8>)
     616:	4d44      	ldr	r5, [pc, #272]	; (728 <encoderA()+0x1c8>)
     618:	681c      	ldr	r4, [r3, #0]
    ARightFalseCount = currentRotateResetDelay;
     61a:	4b41      	ldr	r3, [pc, #260]	; (720 <encoderA()+0x1c0>)
     61c:	6018      	str	r0, [r3, #0]
    ADialMoveRight = false;
     61e:	2300      	movs	r3, #0
     620:	7013      	strb	r3, [r2, #0]
    ADialMoveLeft = false;
     622:	700b      	strb	r3, [r1, #0]
    allButtons[ARotateRightButton] = 1;
     624:	2301      	movs	r3, #1
     626:	552b      	strb	r3, [r5, r4]
    if (ALeftFalseCount != -1) {
     628:	4a40      	ldr	r2, [pc, #256]	; (72c <encoderA()+0x1cc>)
     62a:	6813      	ldr	r3, [r2, #0]
     62c:	1c59      	adds	r1, r3, #1
     62e:	d011      	beq.n	654 <encoderA()+0xf4>
      ALeftFalseCount--;
     630:	3b01      	subs	r3, #1
    if (ALeftFalseCount <= 0) {
     632:	2b00      	cmp	r3, #0
      ALeftFalseCount--;
     634:	6013      	str	r3, [r2, #0]
    if (ALeftFalseCount <= 0) {
     636:	dd0d      	ble.n	654 <encoderA()+0xf4>
}
     638:	b003      	add	sp, #12
     63a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if ((nowms - ALastTickTime) < AMinimumMsForExtendedMove)
     63c:	1bc9      	subs	r1, r1, r7
     63e:	2931      	cmp	r1, #49	; 0x31
        currentRotateResetDelay = AExtendedMoveMs;
     640:	bf9c      	itt	ls
     642:	493e      	ldrls	r1, [pc, #248]	; (73c <encoderA()+0x1dc>)
     644:	6808      	ldrls	r0, [r1, #0]
     646:	e7af      	b.n	5a8 <encoderA()+0x48>
      allButtons[ARotateRightButton] = 0;
     648:	4b3b      	ldr	r3, [pc, #236]	; (738 <encoderA()+0x1d8>)
     64a:	4c37      	ldr	r4, [pc, #220]	; (728 <encoderA()+0x1c8>)
     64c:	681b      	ldr	r3, [r3, #0]
     64e:	2500      	movs	r5, #0
     650:	54e5      	strb	r5, [r4, r3]
     652:	e7c5      	b.n	5e0 <encoderA()+0x80>
      allButtons[ARotateLeftButton] = 0;
     654:	4b33      	ldr	r3, [pc, #204]	; (724 <encoderA()+0x1c4>)
     656:	4a34      	ldr	r2, [pc, #208]	; (728 <encoderA()+0x1c8>)
     658:	681b      	ldr	r3, [r3, #0]
     65a:	2100      	movs	r1, #0
     65c:	54d1      	strb	r1, [r2, r3]
}
     65e:	b003      	add	sp, #12
     660:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (lastStateA == 2) {
     662:	2a02      	cmp	r2, #2
     664:	d023      	beq.n	6ae <encoderA()+0x14e>
        else if (lastStateA == 1) {
     666:	2a01      	cmp	r2, #1
     668:	d1ad      	bne.n	5c6 <encoderA()+0x66>
          stepsA--;
     66a:	4d31      	ldr	r5, [pc, #196]	; (730 <encoderA()+0x1d0>)
          cwA = -1;
     66c:	4e31      	ldr	r6, [pc, #196]	; (734 <encoderA()+0x1d4>)
          stepsA--;
     66e:	7829      	ldrb	r1, [r5, #0]
     670:	3901      	subs	r1, #1
     672:	7029      	strb	r1, [r5, #0]
          ADialMoveLeft = true;
     674:	4929      	ldr	r1, [pc, #164]	; (71c <encoderA()+0x1bc>)
     676:	700a      	strb	r2, [r1, #0]
  if (ADialMoveRight == true)
     678:	4a27      	ldr	r2, [pc, #156]	; (718 <encoderA()+0x1b8>)
          cwA = -1;
     67a:	f04f 35ff 	mov.w	r5, #4294967295
     67e:	6035      	str	r5, [r6, #0]
  if (ADialMoveRight == true)
     680:	7815      	ldrb	r5, [r2, #0]
     682:	e7a3      	b.n	5cc <encoderA()+0x6c>
        if (lastStateA == 3) {
     684:	2a03      	cmp	r2, #3
     686:	d029      	beq.n	6dc <encoderA()+0x17c>
        else if (lastStateA == 0) {
     688:	2a00      	cmp	r2, #0
     68a:	d19c      	bne.n	5c6 <encoderA()+0x66>
          stepsA--;
     68c:	4928      	ldr	r1, [pc, #160]	; (730 <encoderA()+0x1d0>)
     68e:	780a      	ldrb	r2, [r1, #0]
     690:	3a01      	subs	r2, #1
     692:	700a      	strb	r2, [r1, #0]
          cwA = -1;
     694:	4a27      	ldr	r2, [pc, #156]	; (734 <encoderA()+0x1d4>)
     696:	f04f 31ff 	mov.w	r1, #4294967295
     69a:	6011      	str	r1, [r2, #0]
          ADialMoveLeft = true;
     69c:	491f      	ldr	r1, [pc, #124]	; (71c <encoderA()+0x1bc>)
     69e:	2201      	movs	r2, #1
     6a0:	700a      	strb	r2, [r1, #0]
  if (ADialMoveRight == true)
     6a2:	4a1d      	ldr	r2, [pc, #116]	; (718 <encoderA()+0x1b8>)
     6a4:	7815      	ldrb	r5, [r2, #0]
     6a6:	e791      	b.n	5cc <encoderA()+0x6c>
        else if (lastStateA == 3) {
     6a8:	2a03      	cmp	r2, #3
     6aa:	d18c      	bne.n	5c6 <encoderA()+0x66>
     6ac:	e7ee      	b.n	68c <encoderA()+0x12c>
          stepsA++;
     6ae:	4a20      	ldr	r2, [pc, #128]	; (730 <encoderA()+0x1d0>)
          cwA = 1;
     6b0:	4920      	ldr	r1, [pc, #128]	; (734 <encoderA()+0x1d4>)
          stepsA++;
     6b2:	7813      	ldrb	r3, [r2, #0]
     6b4:	3301      	adds	r3, #1
     6b6:	7013      	strb	r3, [r2, #0]
          cwA = 1;
     6b8:	2201      	movs	r2, #1
  lastStateA = AState;
     6ba:	2300      	movs	r3, #0
          cwA = 1;
     6bc:	600a      	str	r2, [r1, #0]
  lastStateA = AState;
     6be:	7023      	strb	r3, [r4, #0]
  if (ADialMoveRight == true)
     6c0:	4a15      	ldr	r2, [pc, #84]	; (718 <encoderA()+0x1b8>)
     6c2:	4916      	ldr	r1, [pc, #88]	; (71c <encoderA()+0x1bc>)
     6c4:	e7a6      	b.n	614 <encoderA()+0xb4>
          stepsA++;
     6c6:	491a      	ldr	r1, [pc, #104]	; (730 <encoderA()+0x1d0>)
     6c8:	780b      	ldrb	r3, [r1, #0]
     6ca:	3301      	adds	r3, #1
     6cc:	700b      	strb	r3, [r1, #0]
          cwA = 1;
     6ce:	4919      	ldr	r1, [pc, #100]	; (734 <encoderA()+0x1d4>)
  lastStateA = AState;
     6d0:	2303      	movs	r3, #3
          cwA = 1;
     6d2:	600a      	str	r2, [r1, #0]
  lastStateA = AState;
     6d4:	7023      	strb	r3, [r4, #0]
  if (ADialMoveRight == true)
     6d6:	4a10      	ldr	r2, [pc, #64]	; (718 <encoderA()+0x1b8>)
     6d8:	4910      	ldr	r1, [pc, #64]	; (71c <encoderA()+0x1bc>)
     6da:	e79b      	b.n	614 <encoderA()+0xb4>
          stepsA++;
     6dc:	4a14      	ldr	r2, [pc, #80]	; (730 <encoderA()+0x1d0>)
          cwA = 1;
     6de:	4915      	ldr	r1, [pc, #84]	; (734 <encoderA()+0x1d4>)
          stepsA++;
     6e0:	7813      	ldrb	r3, [r2, #0]
     6e2:	3301      	adds	r3, #1
     6e4:	7013      	strb	r3, [r2, #0]
          cwA = 1;
     6e6:	2201      	movs	r2, #1
  lastStateA = AState;
     6e8:	2302      	movs	r3, #2
          cwA = 1;
     6ea:	600a      	str	r2, [r1, #0]
  lastStateA = AState;
     6ec:	7023      	strb	r3, [r4, #0]
  if (ADialMoveRight == true)
     6ee:	4a0a      	ldr	r2, [pc, #40]	; (718 <encoderA()+0x1b8>)
     6f0:	490a      	ldr	r1, [pc, #40]	; (71c <encoderA()+0x1bc>)
     6f2:	e78f      	b.n	614 <encoderA()+0xb4>
     6f4:	1fff0b68 	.word	0x1fff0b68
     6f8:	1fff0b69 	.word	0x1fff0b69
     6fc:	1fff0938 	.word	0x1fff0938
     700:	1fff0b78 	.word	0x1fff0b78
     704:	1fff0bc4 	.word	0x1fff0bc4
     708:	1fff0b6a 	.word	0x1fff0b6a
     70c:	1fff0948 	.word	0x1fff0948
     710:	1fff0bf0 	.word	0x1fff0bf0
     714:	1fff0b70 	.word	0x1fff0b70
     718:	1fff0b6c 	.word	0x1fff0b6c
     71c:	1fff0b6b 	.word	0x1fff0b6b
     720:	1fff0944 	.word	0x1fff0944
     724:	1fff0b74 	.word	0x1fff0b74
     728:	1fff0b94 	.word	0x1fff0b94
     72c:	1fff0940 	.word	0x1fff0940
     730:	1fff0be8 	.word	0x1fff0be8
     734:	1fff0bb0 	.word	0x1fff0bb0
     738:	1fff094c 	.word	0x1fff094c
     73c:	1fff093c 	.word	0x1fff093c

00000740 <encoderB()>:

void encoderB() {
     740:	b5f0      	push	{r4, r5, r6, r7, lr}
     742:	b083      	sub	sp, #12
  cli();
     744:	b672      	cpsid	i
  //B1State = VA1State; //digitalRead(B1Input);
  //B2State = VA2State; //digitalRead(B2Input) << 1;
  sei();
     746:	b662      	cpsie	i
  B1State = digitalRead(B1Input);
     748:	4b56      	ldr	r3, [pc, #344]	; (8a4 <encoderB()+0x164>)
     74a:	4c57      	ldr	r4, [pc, #348]	; (8a8 <encoderB()+0x168>)
     74c:	7818      	ldrb	r0, [r3, #0]
     74e:	f000 fd3f 	bl	11d0 <digitalRead>
  B2State = digitalRead(B2Input) << 1;
     752:	4b56      	ldr	r3, [pc, #344]	; (8ac <encoderB()+0x16c>)
  B1State = digitalRead(B1Input);
     754:	7020      	strb	r0, [r4, #0]
  B2State = digitalRead(B2Input) << 1;
     756:	7818      	ldrb	r0, [r3, #0]
     758:	f000 fd3a 	bl	11d0 <digitalRead>

  BState = B1State | B2State;
     75c:	7823      	ldrb	r3, [r4, #0]
     75e:	4a54      	ldr	r2, [pc, #336]	; (8b0 <encoderB()+0x170>)
  int currentRotateResetDelay = BRotateResetDelay;

  //BMinimumMsForExtendedMove = 50;
  //BExtendedMoveMs = 200;

  if (lastStateB != BState) {
     760:	4c54      	ldr	r4, [pc, #336]	; (8b4 <encoderB()+0x174>)
  B2State = digitalRead(B2Input) << 1;
     762:	4955      	ldr	r1, [pc, #340]	; (8b8 <encoderB()+0x178>)
     764:	0040      	lsls	r0, r0, #1
     766:	b2c0      	uxtb	r0, r0
  BState = B1State | B2State;
     768:	4303      	orrs	r3, r0
     76a:	7013      	strb	r3, [r2, #0]
  if (lastStateB != BState) {
     76c:	7822      	ldrb	r2, [r4, #0]
  B2State = digitalRead(B2Input) << 1;
     76e:	7008      	strb	r0, [r1, #0]
  int currentRotateResetDelay = BRotateResetDelay;
     770:	4952      	ldr	r1, [pc, #328]	; (8bc <encoderB()+0x17c>)
  if (lastStateB != BState) {
     772:	4293      	cmp	r3, r2
  int currentRotateResetDelay = BRotateResetDelay;
     774:	6808      	ldr	r0, [r1, #0]
  if (lastStateB != BState) {
     776:	d017      	beq.n	7a8 <encoderB()+0x68>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     778:	4e51      	ldr	r6, [pc, #324]	; (8c0 <encoderB()+0x180>)

    //state has changed, is it close enough to last time that we have to extend 'on' time?
    unsigned int nowms = millis();
    if (BLastTickTime > nowms)
     77a:	4d52      	ldr	r5, [pc, #328]	; (8c4 <encoderB()+0x184>)
     77c:	6831      	ldr	r1, [r6, #0]
     77e:	9100      	str	r1, [sp, #0]
	return ret;
     780:	9900      	ldr	r1, [sp, #0]
     782:	682f      	ldr	r7, [r5, #0]
     784:	428f      	cmp	r7, r1
     786:	d948      	bls.n	81a <encoderB()+0xda>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     788:	6831      	ldr	r1, [r6, #0]
     78a:	9101      	str	r1, [sp, #4]
      }
    }
    BLastTickTime = millis();


    switch (AState) {
     78c:	494e      	ldr	r1, [pc, #312]	; (8c8 <encoderB()+0x188>)
	return ret;
     78e:	9e01      	ldr	r6, [sp, #4]
     790:	7809      	ldrb	r1, [r1, #0]
    BLastTickTime = millis();
     792:	602e      	str	r6, [r5, #0]
    switch (AState) {
     794:	2903      	cmp	r1, #3
     796:	d807      	bhi.n	7a8 <encoderB()+0x68>
     798:	e8df f001 	tbb	[pc, r1]
     79c:	02756352 	.word	0x02756352
          //BDialMoveRight = false;
          BDialMoveLeft = true;
        }
        break;
      case 3:
        if (lastStateB == 1) {
     7a0:	2a01      	cmp	r2, #1
     7a2:	d075      	beq.n	890 <encoderB()+0x150>
          stepsB++;
          cwB = 1;
          BDialMoveRight = true;
          //BDialMoveLeft = false;
        }
        else if (lastStateB == 2) {
     7a4:	2a02      	cmp	r2, #2
     7a6:	d060      	beq.n	86a <encoderB()+0x12a>
  //Serial.print(cwB);
  //Serial.print("\t");
  //Serial.println(stepsB);


  if (BDialMoveRight == true)
     7a8:	4a48      	ldr	r2, [pc, #288]	; (8cc <encoderB()+0x18c>)
     7aa:	4949      	ldr	r1, [pc, #292]	; (8d0 <encoderB()+0x190>)
     7ac:	7815      	ldrb	r5, [r2, #0]
  lastStateB = BState;
     7ae:	7023      	strb	r3, [r4, #0]
  if (BDialMoveRight == true)
     7b0:	b9fd      	cbnz	r5, 7f2 <encoderB()+0xb2>
    allButtons[BRotateRightButton] = 1;
    BDialMoveRight = false;
    BDialMoveLeft = false;
    BRightFalseCount = currentRotateResetDelay;
  } else {
    if (BRightFalseCount != -1) {
     7b2:	4c48      	ldr	r4, [pc, #288]	; (8d4 <encoderB()+0x194>)
     7b4:	6823      	ldr	r3, [r4, #0]
     7b6:	1c5d      	adds	r5, r3, #1
     7b8:	d035      	beq.n	826 <encoderB()+0xe6>
      BRightFalseCount--;
     7ba:	3b01      	subs	r3, #1
    }
    if (BRightFalseCount <= 0) {
     7bc:	2b00      	cmp	r3, #0
      BRightFalseCount--;
     7be:	6023      	str	r3, [r4, #0]
    if (BRightFalseCount <= 0) {
     7c0:	dd31      	ble.n	826 <encoderB()+0xe6>
      allButtons[BRotateRightButton] = 0;
    }
  }
  if (BDialMoveLeft == true)
     7c2:	780b      	ldrb	r3, [r1, #0]
     7c4:	b1fb      	cbz	r3, 806 <encoderB()+0xc6>
  {
    allButtons[BRotateLeftButton] = 1;
     7c6:	4b44      	ldr	r3, [pc, #272]	; (8d8 <encoderB()+0x198>)
     7c8:	4d44      	ldr	r5, [pc, #272]	; (8dc <encoderB()+0x19c>)
     7ca:	681c      	ldr	r4, [r3, #0]
    BDialMoveLeft = false;
    BDialMoveRight = false;
    BLeftFalseCount = currentRotateResetDelay;
     7cc:	4b44      	ldr	r3, [pc, #272]	; (8e0 <encoderB()+0x1a0>)
     7ce:	6018      	str	r0, [r3, #0]
    BDialMoveLeft = false;
     7d0:	2300      	movs	r3, #0
     7d2:	700b      	strb	r3, [r1, #0]
    BDialMoveRight = false;
     7d4:	7013      	strb	r3, [r2, #0]
    allButtons[BRotateLeftButton] = 1;
     7d6:	2301      	movs	r3, #1
     7d8:	552b      	strb	r3, [r5, r4]
    }
    if (BLeftFalseCount <= 0) {
      allButtons[BRotateLeftButton] = 0;
    }
  }
}
     7da:	b003      	add	sp, #12
     7dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
          stepsB++;
     7de:	4a41      	ldr	r2, [pc, #260]	; (8e4 <encoderB()+0x1a4>)
  lastStateB = BState;
     7e0:	7023      	strb	r3, [r4, #0]
          stepsB++;
     7e2:	7813      	ldrb	r3, [r2, #0]
          cwB = 1;
     7e4:	4c40      	ldr	r4, [pc, #256]	; (8e8 <encoderB()+0x1a8>)
     7e6:	493a      	ldr	r1, [pc, #232]	; (8d0 <encoderB()+0x190>)
     7e8:	2501      	movs	r5, #1
          stepsB++;
     7ea:	442b      	add	r3, r5
     7ec:	7013      	strb	r3, [r2, #0]
          cwB = 1;
     7ee:	4a37      	ldr	r2, [pc, #220]	; (8cc <encoderB()+0x18c>)
     7f0:	6025      	str	r5, [r4, #0]
    allButtons[BRotateRightButton] = 1;
     7f2:	4b3e      	ldr	r3, [pc, #248]	; (8ec <encoderB()+0x1ac>)
     7f4:	4d39      	ldr	r5, [pc, #228]	; (8dc <encoderB()+0x19c>)
     7f6:	681c      	ldr	r4, [r3, #0]
    BRightFalseCount = currentRotateResetDelay;
     7f8:	4b36      	ldr	r3, [pc, #216]	; (8d4 <encoderB()+0x194>)
     7fa:	6018      	str	r0, [r3, #0]
    BDialMoveRight = false;
     7fc:	2300      	movs	r3, #0
     7fe:	7013      	strb	r3, [r2, #0]
    BDialMoveLeft = false;
     800:	700b      	strb	r3, [r1, #0]
    allButtons[BRotateRightButton] = 1;
     802:	2301      	movs	r3, #1
     804:	552b      	strb	r3, [r5, r4]
    if (BLeftFalseCount != -1) {
     806:	4a36      	ldr	r2, [pc, #216]	; (8e0 <encoderB()+0x1a0>)
     808:	6813      	ldr	r3, [r2, #0]
     80a:	1c59      	adds	r1, r3, #1
     80c:	d011      	beq.n	832 <encoderB()+0xf2>
      BLeftFalseCount--;
     80e:	3b01      	subs	r3, #1
    if (BLeftFalseCount <= 0) {
     810:	2b00      	cmp	r3, #0
      BLeftFalseCount--;
     812:	6013      	str	r3, [r2, #0]
    if (BLeftFalseCount <= 0) {
     814:	dd0d      	ble.n	832 <encoderB()+0xf2>
}
     816:	b003      	add	sp, #12
     818:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if ((nowms - BLastTickTime) < BMinimumMsForExtendedMove)
     81a:	1bc9      	subs	r1, r1, r7
     81c:	2931      	cmp	r1, #49	; 0x31
        currentRotateResetDelay = BExtendedMoveMs;
     81e:	bf9c      	itt	ls
     820:	4933      	ldrls	r1, [pc, #204]	; (8f0 <encoderB()+0x1b0>)
     822:	6808      	ldrls	r0, [r1, #0]
     824:	e7b0      	b.n	788 <encoderB()+0x48>
      allButtons[BRotateRightButton] = 0;
     826:	4b31      	ldr	r3, [pc, #196]	; (8ec <encoderB()+0x1ac>)
     828:	4c2c      	ldr	r4, [pc, #176]	; (8dc <encoderB()+0x19c>)
     82a:	681b      	ldr	r3, [r3, #0]
     82c:	2500      	movs	r5, #0
     82e:	54e5      	strb	r5, [r4, r3]
     830:	e7c7      	b.n	7c2 <encoderB()+0x82>
      allButtons[BRotateLeftButton] = 0;
     832:	4b29      	ldr	r3, [pc, #164]	; (8d8 <encoderB()+0x198>)
     834:	4a29      	ldr	r2, [pc, #164]	; (8dc <encoderB()+0x19c>)
     836:	681b      	ldr	r3, [r3, #0]
     838:	2100      	movs	r1, #0
     83a:	54d1      	strb	r1, [r2, r3]
}
     83c:	b003      	add	sp, #12
     83e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (lastStateB == 2) {
     840:	2a02      	cmp	r2, #2
     842:	d0cc      	beq.n	7de <encoderB()+0x9e>
        else if (lastStateB == 1) {
     844:	2a01      	cmp	r2, #1
     846:	d1af      	bne.n	7a8 <encoderB()+0x68>
          stepsB--;
     848:	4d26      	ldr	r5, [pc, #152]	; (8e4 <encoderB()+0x1a4>)
          cwB = -1;
     84a:	4e27      	ldr	r6, [pc, #156]	; (8e8 <encoderB()+0x1a8>)
          stepsB--;
     84c:	7829      	ldrb	r1, [r5, #0]
     84e:	3901      	subs	r1, #1
     850:	7029      	strb	r1, [r5, #0]
          BDialMoveLeft = true;
     852:	491f      	ldr	r1, [pc, #124]	; (8d0 <encoderB()+0x190>)
     854:	700a      	strb	r2, [r1, #0]
  if (BDialMoveRight == true)
     856:	4a1d      	ldr	r2, [pc, #116]	; (8cc <encoderB()+0x18c>)
          cwB = -1;
     858:	f04f 35ff 	mov.w	r5, #4294967295
     85c:	6035      	str	r5, [r6, #0]
  if (BDialMoveRight == true)
     85e:	7815      	ldrb	r5, [r2, #0]
     860:	e7a5      	b.n	7ae <encoderB()+0x6e>
        if (lastStateB == 0) {
     862:	2a00      	cmp	r2, #0
     864:	d0bb      	beq.n	7de <encoderB()+0x9e>
        else if (lastStateB == 3) {
     866:	2a03      	cmp	r2, #3
     868:	d19e      	bne.n	7a8 <encoderB()+0x68>
          stepsB--;
     86a:	491e      	ldr	r1, [pc, #120]	; (8e4 <encoderB()+0x1a4>)
     86c:	780a      	ldrb	r2, [r1, #0]
     86e:	3a01      	subs	r2, #1
     870:	700a      	strb	r2, [r1, #0]
          cwB = -1;
     872:	4a1d      	ldr	r2, [pc, #116]	; (8e8 <encoderB()+0x1a8>)
     874:	f04f 31ff 	mov.w	r1, #4294967295
     878:	6011      	str	r1, [r2, #0]
          BDialMoveLeft = true;
     87a:	4915      	ldr	r1, [pc, #84]	; (8d0 <encoderB()+0x190>)
     87c:	2201      	movs	r2, #1
     87e:	700a      	strb	r2, [r1, #0]
  if (BDialMoveRight == true)
     880:	4a12      	ldr	r2, [pc, #72]	; (8cc <encoderB()+0x18c>)
     882:	7815      	ldrb	r5, [r2, #0]
     884:	e793      	b.n	7ae <encoderB()+0x6e>
        if (lastStateB == 3) {
     886:	2a03      	cmp	r2, #3
     888:	d0a9      	beq.n	7de <encoderB()+0x9e>
        else if (lastStateB == 0) {
     88a:	2a00      	cmp	r2, #0
     88c:	d0ed      	beq.n	86a <encoderB()+0x12a>
     88e:	e78b      	b.n	7a8 <encoderB()+0x68>
  lastStateB = BState;
     890:	7023      	strb	r3, [r4, #0]
          stepsB++;
     892:	4c14      	ldr	r4, [pc, #80]	; (8e4 <encoderB()+0x1a4>)
          cwB = 1;
     894:	4914      	ldr	r1, [pc, #80]	; (8e8 <encoderB()+0x1a8>)
          stepsB++;
     896:	7823      	ldrb	r3, [r4, #0]
          cwB = 1;
     898:	600a      	str	r2, [r1, #0]
          stepsB++;
     89a:	3301      	adds	r3, #1
     89c:	4a0b      	ldr	r2, [pc, #44]	; (8cc <encoderB()+0x18c>)
     89e:	490c      	ldr	r1, [pc, #48]	; (8d0 <encoderB()+0x190>)
     8a0:	7023      	strb	r3, [r4, #0]
  if (BDialMoveRight == true)
     8a2:	e7a6      	b.n	7f2 <encoderB()+0xb2>
     8a4:	1fff0950 	.word	0x1fff0950
     8a8:	1fff0b79 	.word	0x1fff0b79
     8ac:	1fff0951 	.word	0x1fff0951
     8b0:	1fff0b84 	.word	0x1fff0b84
     8b4:	1fff0bc5 	.word	0x1fff0bc5
     8b8:	1fff0b7a 	.word	0x1fff0b7a
     8bc:	1fff0964 	.word	0x1fff0964
     8c0:	1fff0bf0 	.word	0x1fff0bf0
     8c4:	1fff0b80 	.word	0x1fff0b80
     8c8:	1fff0b78 	.word	0x1fff0b78
     8cc:	1fff0b7c 	.word	0x1fff0b7c
     8d0:	1fff0b7b 	.word	0x1fff0b7b
     8d4:	1fff095c 	.word	0x1fff095c
     8d8:	1fff0960 	.word	0x1fff0960
     8dc:	1fff0b94 	.word	0x1fff0b94
     8e0:	1fff0958 	.word	0x1fff0958
     8e4:	1fff0be9 	.word	0x1fff0be9
     8e8:	1fff0bb4 	.word	0x1fff0bb4
     8ec:	1fff0968 	.word	0x1fff0968
     8f0:	1fff0954 	.word	0x1fff0954

000008f4 <encoderC()>:

void encoderC() {
     8f4:	b538      	push	{r3, r4, r5, lr}
  // read the input pin:
  //cli();
  //C1State = VC1State; //digitalRead(C1Input);
  //B2State = VC2State; //digitalRead(C2Input) << 1;
  //sei();
  C1State = digitalRead(C1Input);
     8f6:	4b41      	ldr	r3, [pc, #260]	; (9fc <encoderC()+0x108>)
     8f8:	4c41      	ldr	r4, [pc, #260]	; (a00 <encoderC()+0x10c>)
     8fa:	7818      	ldrb	r0, [r3, #0]
     8fc:	f000 fc68 	bl	11d0 <digitalRead>
  C2State = digitalRead(C2Input) << 1;
     900:	4b40      	ldr	r3, [pc, #256]	; (a04 <encoderC()+0x110>)
  C1State = digitalRead(C1Input);
     902:	7020      	strb	r0, [r4, #0]
  C2State = digitalRead(C2Input) << 1;
     904:	7818      	ldrb	r0, [r3, #0]
     906:	f000 fc63 	bl	11d0 <digitalRead>

  CState = C1State | C2State;
     90a:	7823      	ldrb	r3, [r4, #0]
     90c:	4a3e      	ldr	r2, [pc, #248]	; (a08 <encoderC()+0x114>)

  if (lastStateC != CState) {
     90e:	4c3f      	ldr	r4, [pc, #252]	; (a0c <encoderC()+0x118>)
  C2State = digitalRead(C2Input) << 1;
     910:	493f      	ldr	r1, [pc, #252]	; (a10 <encoderC()+0x11c>)
     912:	0040      	lsls	r0, r0, #1
     914:	b2c0      	uxtb	r0, r0
  CState = C1State | C2State;
     916:	4303      	orrs	r3, r0
     918:	7013      	strb	r3, [r2, #0]
  if (lastStateC != CState) {
     91a:	7822      	ldrb	r2, [r4, #0]
  C2State = digitalRead(C2Input) << 1;
     91c:	7008      	strb	r0, [r1, #0]
  if (lastStateC != CState) {
     91e:	4293      	cmp	r3, r2
     920:	d009      	beq.n	936 <encoderC()+0x42>
    switch (CState) {
     922:	2b03      	cmp	r3, #3
     924:	d807      	bhi.n	936 <encoderC()+0x42>
     926:	e8df f003 	tbb	[pc, r3]
     92a:	5e02      	.short	0x5e02
     92c:	4c63      	.short	0x4c63
      case 0:
        if (lastStateC == 2) {
     92e:	2a02      	cmp	r2, #2
     930:	d01d      	beq.n	96e <encoderC()+0x7a>
          stepsC++;
          cwC = 1;
          CDialMoveRight = true;
          //CDialMoveLeft = false;
        }
        else if (lastStateC == 1) {
     932:	2a01      	cmp	r2, #1
     934:	d049      	beq.n	9ca <encoderC()+0xd6>
  }

  lastStateC = CState;


  if (CDialMoveRight == true)
     936:	4a37      	ldr	r2, [pc, #220]	; (a14 <encoderC()+0x120>)
     938:	4937      	ldr	r1, [pc, #220]	; (a18 <encoderC()+0x124>)
     93a:	7810      	ldrb	r0, [r2, #0]
  lastStateC = CState;
     93c:	7023      	strb	r3, [r4, #0]
  if (CDialMoveRight == true)
     93e:	bb00      	cbnz	r0, 982 <encoderC()+0x8e>
    allButtons[CRotateRightButton] = 1;
    CDialMoveRight = false;
    CDialMoveLeft = false;
    CRightFalseCount = CRotateResetDelay;
  } else {
    if (CRightFalseCount != -1) {
     940:	4836      	ldr	r0, [pc, #216]	; (a1c <encoderC()+0x128>)
     942:	6803      	ldr	r3, [r0, #0]
     944:	1c5c      	adds	r4, r3, #1
     946:	d036      	beq.n	9b6 <encoderC()+0xc2>
      CRightFalseCount--;
     948:	3b01      	subs	r3, #1
    }
    if (CRightFalseCount <= 0) {
     94a:	2b00      	cmp	r3, #0
      CRightFalseCount--;
     94c:	6003      	str	r3, [r0, #0]
    if (CRightFalseCount <= 0) {
     94e:	dd32      	ble.n	9b6 <encoderC()+0xc2>
      allButtons[CRotateRightButton] = 0;
    }
  }
  if (CDialMoveLeft == true)
     950:	780b      	ldrb	r3, [r1, #0]
     952:	b313      	cbz	r3, 99a <encoderC()+0xa6>
  {
    allButtons[CRotateLeftButton] = 1;
    CDialMoveLeft = false;
    CDialMoveRight = false;
    CLeftFalseCount = CRotateResetDelay;
     954:	4b32      	ldr	r3, [pc, #200]	; (a20 <encoderC()+0x12c>)
    allButtons[CRotateLeftButton] = 1;
     956:	4833      	ldr	r0, [pc, #204]	; (a24 <encoderC()+0x130>)
    CLeftFalseCount = CRotateResetDelay;
     958:	681d      	ldr	r5, [r3, #0]
     95a:	4b33      	ldr	r3, [pc, #204]	; (a28 <encoderC()+0x134>)
    allButtons[CRotateLeftButton] = 1;
     95c:	4c33      	ldr	r4, [pc, #204]	; (a2c <encoderC()+0x138>)
     95e:	6800      	ldr	r0, [r0, #0]
    CLeftFalseCount = CRotateResetDelay;
     960:	601d      	str	r5, [r3, #0]
    CDialMoveLeft = false;
     962:	2300      	movs	r3, #0
     964:	700b      	strb	r3, [r1, #0]
    CDialMoveRight = false;
     966:	7013      	strb	r3, [r2, #0]
    allButtons[CRotateLeftButton] = 1;
     968:	2301      	movs	r3, #1
     96a:	5423      	strb	r3, [r4, r0]
    }
    if (CLeftFalseCount <= 0) {
      allButtons[CRotateLeftButton] = 0;
    }
  }
}
     96c:	bd38      	pop	{r3, r4, r5, pc}
          stepsC++;
     96e:	4830      	ldr	r0, [pc, #192]	; (a30 <encoderC()+0x13c>)
          cwC = 1;
     970:	4d30      	ldr	r5, [pc, #192]	; (a34 <encoderC()+0x140>)
          stepsC++;
     972:	7802      	ldrb	r2, [r0, #0]
  lastStateC = CState;
     974:	7023      	strb	r3, [r4, #0]
          stepsC++;
     976:	1c53      	adds	r3, r2, #1
     978:	7003      	strb	r3, [r0, #0]
          cwC = 1;
     97a:	4a26      	ldr	r2, [pc, #152]	; (a14 <encoderC()+0x120>)
     97c:	4926      	ldr	r1, [pc, #152]	; (a18 <encoderC()+0x124>)
     97e:	2301      	movs	r3, #1
     980:	602b      	str	r3, [r5, #0]
    CRightFalseCount = CRotateResetDelay;
     982:	4b27      	ldr	r3, [pc, #156]	; (a20 <encoderC()+0x12c>)
    allButtons[CRotateRightButton] = 1;
     984:	482c      	ldr	r0, [pc, #176]	; (a38 <encoderC()+0x144>)
    CRightFalseCount = CRotateResetDelay;
     986:	681d      	ldr	r5, [r3, #0]
     988:	4b24      	ldr	r3, [pc, #144]	; (a1c <encoderC()+0x128>)
    allButtons[CRotateRightButton] = 1;
     98a:	4c28      	ldr	r4, [pc, #160]	; (a2c <encoderC()+0x138>)
     98c:	6800      	ldr	r0, [r0, #0]
    CRightFalseCount = CRotateResetDelay;
     98e:	601d      	str	r5, [r3, #0]
    CDialMoveRight = false;
     990:	2300      	movs	r3, #0
     992:	7013      	strb	r3, [r2, #0]
    CDialMoveLeft = false;
     994:	700b      	strb	r3, [r1, #0]
    allButtons[CRotateRightButton] = 1;
     996:	2301      	movs	r3, #1
     998:	5423      	strb	r3, [r4, r0]
    if (CLeftFalseCount != -1) {
     99a:	4a23      	ldr	r2, [pc, #140]	; (a28 <encoderC()+0x134>)
     99c:	6813      	ldr	r3, [r2, #0]
     99e:	1c59      	adds	r1, r3, #1
     9a0:	d003      	beq.n	9aa <encoderC()+0xb6>
      CLeftFalseCount--;
     9a2:	3b01      	subs	r3, #1
    if (CLeftFalseCount <= 0) {
     9a4:	2b00      	cmp	r3, #0
      CLeftFalseCount--;
     9a6:	6013      	str	r3, [r2, #0]
    if (CLeftFalseCount <= 0) {
     9a8:	dce0      	bgt.n	96c <encoderC()+0x78>
      allButtons[CRotateLeftButton] = 0;
     9aa:	4b1e      	ldr	r3, [pc, #120]	; (a24 <encoderC()+0x130>)
     9ac:	4a1f      	ldr	r2, [pc, #124]	; (a2c <encoderC()+0x138>)
     9ae:	681b      	ldr	r3, [r3, #0]
     9b0:	2100      	movs	r1, #0
     9b2:	54d1      	strb	r1, [r2, r3]
}
     9b4:	bd38      	pop	{r3, r4, r5, pc}
      allButtons[CRotateRightButton] = 0;
     9b6:	4b20      	ldr	r3, [pc, #128]	; (a38 <encoderC()+0x144>)
     9b8:	481c      	ldr	r0, [pc, #112]	; (a2c <encoderC()+0x138>)
     9ba:	681b      	ldr	r3, [r3, #0]
     9bc:	2400      	movs	r4, #0
     9be:	54c4      	strb	r4, [r0, r3]
     9c0:	e7c6      	b.n	950 <encoderC()+0x5c>
        if (lastStateC == 1) {
     9c2:	2a01      	cmp	r2, #1
     9c4:	d0d3      	beq.n	96e <encoderC()+0x7a>
        else if (lastStateC == 2) {
     9c6:	2a02      	cmp	r2, #2
     9c8:	d1b5      	bne.n	936 <encoderC()+0x42>
          stepsC--;
     9ca:	4919      	ldr	r1, [pc, #100]	; (a30 <encoderC()+0x13c>)
          cwC = -1;
     9cc:	4819      	ldr	r0, [pc, #100]	; (a34 <encoderC()+0x140>)
          stepsC--;
     9ce:	780a      	ldrb	r2, [r1, #0]
     9d0:	3a01      	subs	r2, #1
     9d2:	700a      	strb	r2, [r1, #0]
          cwC = -1;
     9d4:	f04f 35ff 	mov.w	r5, #4294967295
          CDialMoveLeft = true;
     9d8:	490f      	ldr	r1, [pc, #60]	; (a18 <encoderC()+0x124>)
  if (CDialMoveRight == true)
     9da:	4a0e      	ldr	r2, [pc, #56]	; (a14 <encoderC()+0x120>)
          cwC = -1;
     9dc:	6005      	str	r5, [r0, #0]
          CDialMoveLeft = true;
     9de:	2001      	movs	r0, #1
     9e0:	7008      	strb	r0, [r1, #0]
  if (CDialMoveRight == true)
     9e2:	7810      	ldrb	r0, [r2, #0]
     9e4:	e7aa      	b.n	93c <encoderC()+0x48>
        if (lastStateC == 0) {
     9e6:	2a00      	cmp	r2, #0
     9e8:	d0c1      	beq.n	96e <encoderC()+0x7a>
        else if (lastStateC == 3) {
     9ea:	2a03      	cmp	r2, #3
     9ec:	d1a3      	bne.n	936 <encoderC()+0x42>
     9ee:	e7ec      	b.n	9ca <encoderC()+0xd6>
        if (lastStateC == 3) {
     9f0:	2a03      	cmp	r2, #3
     9f2:	d0bc      	beq.n	96e <encoderC()+0x7a>
        else if (lastStateC == 0) {
     9f4:	2a00      	cmp	r2, #0
     9f6:	d0e8      	beq.n	9ca <encoderC()+0xd6>
     9f8:	e79d      	b.n	936 <encoderC()+0x42>
     9fa:	bf00      	nop
     9fc:	1fff096c 	.word	0x1fff096c
     a00:	1fff0b85 	.word	0x1fff0b85
     a04:	1fff096d 	.word	0x1fff096d
     a08:	1fff0b89 	.word	0x1fff0b89
     a0c:	1fff0bc6 	.word	0x1fff0bc6
     a10:	1fff0b86 	.word	0x1fff0b86
     a14:	1fff0b88 	.word	0x1fff0b88
     a18:	1fff0b87 	.word	0x1fff0b87
     a1c:	1fff0974 	.word	0x1fff0974
     a20:	1fff097c 	.word	0x1fff097c
     a24:	1fff0978 	.word	0x1fff0978
     a28:	1fff0970 	.word	0x1fff0970
     a2c:	1fff0b94 	.word	0x1fff0b94
     a30:	1fff0bea 	.word	0x1fff0bea
     a34:	1fff0bb8 	.word	0x1fff0bb8
     a38:	1fff0980 	.word	0x1fff0980

00000a3c <encoderD()>:

void encoderD() {
     a3c:	b538      	push	{r3, r4, r5, lr}
  // read the input pin:
  //cli();
  //D1State = VD1State; //digitalRead(D1Input);
  //D2State = VD2State; //digitalRead(D2Input) << 1;
  //sei();
  D1State = digitalRead(D1Input);
     a3e:	4b41      	ldr	r3, [pc, #260]	; (b44 <encoderD()+0x108>)
     a40:	4c41      	ldr	r4, [pc, #260]	; (b48 <encoderD()+0x10c>)
     a42:	7818      	ldrb	r0, [r3, #0]
     a44:	f000 fbc4 	bl	11d0 <digitalRead>
  D2State = digitalRead(D2Input) << 1;
     a48:	4b40      	ldr	r3, [pc, #256]	; (b4c <encoderD()+0x110>)
  D1State = digitalRead(D1Input);
     a4a:	7020      	strb	r0, [r4, #0]
  D2State = digitalRead(D2Input) << 1;
     a4c:	7818      	ldrb	r0, [r3, #0]
     a4e:	f000 fbbf 	bl	11d0 <digitalRead>

  DState = D1State | D2State;
     a52:	7823      	ldrb	r3, [r4, #0]
     a54:	4a3e      	ldr	r2, [pc, #248]	; (b50 <encoderD()+0x114>)

  if (lastStateD != DState) {
     a56:	4c3f      	ldr	r4, [pc, #252]	; (b54 <encoderD()+0x118>)
  D2State = digitalRead(D2Input) << 1;
     a58:	493f      	ldr	r1, [pc, #252]	; (b58 <encoderD()+0x11c>)
     a5a:	0040      	lsls	r0, r0, #1
     a5c:	b2c0      	uxtb	r0, r0
  DState = D1State | D2State;
     a5e:	4303      	orrs	r3, r0
     a60:	7013      	strb	r3, [r2, #0]
  if (lastStateD != DState) {
     a62:	7822      	ldrb	r2, [r4, #0]
  D2State = digitalRead(D2Input) << 1;
     a64:	7008      	strb	r0, [r1, #0]
  if (lastStateD != DState) {
     a66:	4293      	cmp	r3, r2
     a68:	d009      	beq.n	a7e <encoderD()+0x42>
    switch (DState) {
     a6a:	2b03      	cmp	r3, #3
     a6c:	d807      	bhi.n	a7e <encoderD()+0x42>
     a6e:	e8df f003 	tbb	[pc, r3]
     a72:	5e02      	.short	0x5e02
     a74:	4c63      	.short	0x4c63
      case 0:
        if (lastStateD == 2) {
     a76:	2a02      	cmp	r2, #2
     a78:	d01d      	beq.n	ab6 <encoderD()+0x7a>
          stepsD++;
          cwD = 1;
          DDialMoveRight = true;
          //DDialMoveLeft = false;
        }
        else if (lastStateD == 1) {
     a7a:	2a01      	cmp	r2, #1
     a7c:	d049      	beq.n	b12 <encoderD()+0xd6>
  }

  lastStateD = DState;


  if (DDialMoveRight == true)
     a7e:	4a37      	ldr	r2, [pc, #220]	; (b5c <encoderD()+0x120>)
     a80:	4937      	ldr	r1, [pc, #220]	; (b60 <encoderD()+0x124>)
     a82:	7810      	ldrb	r0, [r2, #0]
  lastStateD = DState;
     a84:	7023      	strb	r3, [r4, #0]
  if (DDialMoveRight == true)
     a86:	bb00      	cbnz	r0, aca <encoderD()+0x8e>
    allButtons[DRotateRightButton] = 1;
    DDialMoveRight = false;
    DDialMoveLeft = false;
    DRightFalseCount = DRotateResetDelay;
  } else {
    if (DRightFalseCount != -1) {
     a88:	4836      	ldr	r0, [pc, #216]	; (b64 <encoderD()+0x128>)
     a8a:	6803      	ldr	r3, [r0, #0]
     a8c:	1c5c      	adds	r4, r3, #1
     a8e:	d036      	beq.n	afe <encoderD()+0xc2>
      DRightFalseCount--;
     a90:	3b01      	subs	r3, #1
    }
    if (DRightFalseCount <= 0) {
     a92:	2b00      	cmp	r3, #0
      DRightFalseCount--;
     a94:	6003      	str	r3, [r0, #0]
    if (DRightFalseCount <= 0) {
     a96:	dd32      	ble.n	afe <encoderD()+0xc2>
      allButtons[DRotateRightButton] = 0;
    }
  }
  if (DDialMoveLeft == true)
     a98:	780b      	ldrb	r3, [r1, #0]
     a9a:	b313      	cbz	r3, ae2 <encoderD()+0xa6>
  {
    allButtons[DRotateLeftButton] = 1;
    DDialMoveLeft = false;
    DDialMoveRight = false;
    DLeftFalseCount = DRotateResetDelay;
     a9c:	4b32      	ldr	r3, [pc, #200]	; (b68 <encoderD()+0x12c>)
    allButtons[DRotateLeftButton] = 1;
     a9e:	4833      	ldr	r0, [pc, #204]	; (b6c <encoderD()+0x130>)
    DLeftFalseCount = DRotateResetDelay;
     aa0:	681d      	ldr	r5, [r3, #0]
     aa2:	4b33      	ldr	r3, [pc, #204]	; (b70 <encoderD()+0x134>)
    allButtons[DRotateLeftButton] = 1;
     aa4:	4c33      	ldr	r4, [pc, #204]	; (b74 <encoderD()+0x138>)
     aa6:	6800      	ldr	r0, [r0, #0]
    DLeftFalseCount = DRotateResetDelay;
     aa8:	601d      	str	r5, [r3, #0]
    DDialMoveLeft = false;
     aaa:	2300      	movs	r3, #0
     aac:	700b      	strb	r3, [r1, #0]
    DDialMoveRight = false;
     aae:	7013      	strb	r3, [r2, #0]
    allButtons[DRotateLeftButton] = 1;
     ab0:	2301      	movs	r3, #1
     ab2:	5423      	strb	r3, [r4, r0]
    }
    if (DLeftFalseCount <= 0) {
      allButtons[DRotateLeftButton] = 0;
    }
  }
}
     ab4:	bd38      	pop	{r3, r4, r5, pc}
          stepsD++;
     ab6:	4830      	ldr	r0, [pc, #192]	; (b78 <encoderD()+0x13c>)
          cwD = 1;
     ab8:	4d30      	ldr	r5, [pc, #192]	; (b7c <encoderD()+0x140>)
          stepsD++;
     aba:	7802      	ldrb	r2, [r0, #0]
  lastStateD = DState;
     abc:	7023      	strb	r3, [r4, #0]
          stepsD++;
     abe:	1c53      	adds	r3, r2, #1
     ac0:	7003      	strb	r3, [r0, #0]
          cwD = 1;
     ac2:	4a26      	ldr	r2, [pc, #152]	; (b5c <encoderD()+0x120>)
     ac4:	4926      	ldr	r1, [pc, #152]	; (b60 <encoderD()+0x124>)
     ac6:	2301      	movs	r3, #1
     ac8:	602b      	str	r3, [r5, #0]
    DRightFalseCount = DRotateResetDelay;
     aca:	4b27      	ldr	r3, [pc, #156]	; (b68 <encoderD()+0x12c>)
    allButtons[DRotateRightButton] = 1;
     acc:	482c      	ldr	r0, [pc, #176]	; (b80 <encoderD()+0x144>)
    DRightFalseCount = DRotateResetDelay;
     ace:	681d      	ldr	r5, [r3, #0]
     ad0:	4b24      	ldr	r3, [pc, #144]	; (b64 <encoderD()+0x128>)
    allButtons[DRotateRightButton] = 1;
     ad2:	4c28      	ldr	r4, [pc, #160]	; (b74 <encoderD()+0x138>)
     ad4:	6800      	ldr	r0, [r0, #0]
    DRightFalseCount = DRotateResetDelay;
     ad6:	601d      	str	r5, [r3, #0]
    DDialMoveRight = false;
     ad8:	2300      	movs	r3, #0
     ada:	7013      	strb	r3, [r2, #0]
    DDialMoveLeft = false;
     adc:	700b      	strb	r3, [r1, #0]
    allButtons[DRotateRightButton] = 1;
     ade:	2301      	movs	r3, #1
     ae0:	5423      	strb	r3, [r4, r0]
    if (DLeftFalseCount != -1) {
     ae2:	4a23      	ldr	r2, [pc, #140]	; (b70 <encoderD()+0x134>)
     ae4:	6813      	ldr	r3, [r2, #0]
     ae6:	1c59      	adds	r1, r3, #1
     ae8:	d003      	beq.n	af2 <encoderD()+0xb6>
      DLeftFalseCount--;
     aea:	3b01      	subs	r3, #1
    if (DLeftFalseCount <= 0) {
     aec:	2b00      	cmp	r3, #0
      DLeftFalseCount--;
     aee:	6013      	str	r3, [r2, #0]
    if (DLeftFalseCount <= 0) {
     af0:	dce0      	bgt.n	ab4 <encoderD()+0x78>
      allButtons[DRotateLeftButton] = 0;
     af2:	4b1e      	ldr	r3, [pc, #120]	; (b6c <encoderD()+0x130>)
     af4:	4a1f      	ldr	r2, [pc, #124]	; (b74 <encoderD()+0x138>)
     af6:	681b      	ldr	r3, [r3, #0]
     af8:	2100      	movs	r1, #0
     afa:	54d1      	strb	r1, [r2, r3]
}
     afc:	bd38      	pop	{r3, r4, r5, pc}
      allButtons[DRotateRightButton] = 0;
     afe:	4b20      	ldr	r3, [pc, #128]	; (b80 <encoderD()+0x144>)
     b00:	481c      	ldr	r0, [pc, #112]	; (b74 <encoderD()+0x138>)
     b02:	681b      	ldr	r3, [r3, #0]
     b04:	2400      	movs	r4, #0
     b06:	54c4      	strb	r4, [r0, r3]
     b08:	e7c6      	b.n	a98 <encoderD()+0x5c>
        if (lastStateD == 1) {
     b0a:	2a01      	cmp	r2, #1
     b0c:	d0d3      	beq.n	ab6 <encoderD()+0x7a>
        else if (lastStateD == 2) {
     b0e:	2a02      	cmp	r2, #2
     b10:	d1b5      	bne.n	a7e <encoderD()+0x42>
          stepsD--;
     b12:	4919      	ldr	r1, [pc, #100]	; (b78 <encoderD()+0x13c>)
          cwD = -1;
     b14:	4819      	ldr	r0, [pc, #100]	; (b7c <encoderD()+0x140>)
          stepsD--;
     b16:	780a      	ldrb	r2, [r1, #0]
     b18:	3a01      	subs	r2, #1
     b1a:	700a      	strb	r2, [r1, #0]
          cwD = -1;
     b1c:	f04f 35ff 	mov.w	r5, #4294967295
          DDialMoveLeft = true;
     b20:	490f      	ldr	r1, [pc, #60]	; (b60 <encoderD()+0x124>)
  if (DDialMoveRight == true)
     b22:	4a0e      	ldr	r2, [pc, #56]	; (b5c <encoderD()+0x120>)
          cwD = -1;
     b24:	6005      	str	r5, [r0, #0]
          DDialMoveLeft = true;
     b26:	2001      	movs	r0, #1
     b28:	7008      	strb	r0, [r1, #0]
  if (DDialMoveRight == true)
     b2a:	7810      	ldrb	r0, [r2, #0]
     b2c:	e7aa      	b.n	a84 <encoderD()+0x48>
        if (lastStateD == 0) {
     b2e:	2a00      	cmp	r2, #0
     b30:	d0c1      	beq.n	ab6 <encoderD()+0x7a>
        else if (lastStateD == 3) {
     b32:	2a03      	cmp	r2, #3
     b34:	d1a3      	bne.n	a7e <encoderD()+0x42>
     b36:	e7ec      	b.n	b12 <encoderD()+0xd6>
        if (lastStateD == 3) {
     b38:	2a03      	cmp	r2, #3
     b3a:	d0bc      	beq.n	ab6 <encoderD()+0x7a>
        else if (lastStateD == 0) {
     b3c:	2a00      	cmp	r2, #0
     b3e:	d0e8      	beq.n	b12 <encoderD()+0xd6>
     b40:	e79d      	b.n	a7e <encoderD()+0x42>
     b42:	bf00      	nop
     b44:	1fff0984 	.word	0x1fff0984
     b48:	1fff0b8a 	.word	0x1fff0b8a
     b4c:	1fff0985 	.word	0x1fff0985
     b50:	1fff0b8e 	.word	0x1fff0b8e
     b54:	1fff0bc7 	.word	0x1fff0bc7
     b58:	1fff0b8b 	.word	0x1fff0b8b
     b5c:	1fff0b8d 	.word	0x1fff0b8d
     b60:	1fff0b8c 	.word	0x1fff0b8c
     b64:	1fff098c 	.word	0x1fff098c
     b68:	1fff0994 	.word	0x1fff0994
     b6c:	1fff0990 	.word	0x1fff0990
     b70:	1fff0988 	.word	0x1fff0988
     b74:	1fff0b94 	.word	0x1fff0b94
     b78:	1fff0beb 	.word	0x1fff0beb
     b7c:	1fff0bbc 	.word	0x1fff0bbc
     b80:	1fff0998 	.word	0x1fff0998

00000b84 <encoderE()>:

void encoderE() {
     b84:	b538      	push	{r3, r4, r5, lr}
  // read the input pin:
  //cli();
  //E1State = VE1State; //digitalRead(E1Input);
  //E2State = VE2State; //digitalRead(E2Input) << 1;
  //sei();
  E1State = digitalRead(E1Input);
     b86:	4b41      	ldr	r3, [pc, #260]	; (c8c <encoderE()+0x108>)
     b88:	4c41      	ldr	r4, [pc, #260]	; (c90 <encoderE()+0x10c>)
     b8a:	7818      	ldrb	r0, [r3, #0]
     b8c:	f000 fb20 	bl	11d0 <digitalRead>
  E2State = digitalRead(E2Input) << 1;
     b90:	4b40      	ldr	r3, [pc, #256]	; (c94 <encoderE()+0x110>)
  E1State = digitalRead(E1Input);
     b92:	7020      	strb	r0, [r4, #0]
  E2State = digitalRead(E2Input) << 1;
     b94:	7818      	ldrb	r0, [r3, #0]
     b96:	f000 fb1b 	bl	11d0 <digitalRead>

  EState = E1State | E2State;
     b9a:	7823      	ldrb	r3, [r4, #0]
     b9c:	4a3e      	ldr	r2, [pc, #248]	; (c98 <encoderE()+0x114>)

  if (lastStateE != EState) {
     b9e:	4c3f      	ldr	r4, [pc, #252]	; (c9c <encoderE()+0x118>)
  E2State = digitalRead(E2Input) << 1;
     ba0:	493f      	ldr	r1, [pc, #252]	; (ca0 <encoderE()+0x11c>)
     ba2:	0040      	lsls	r0, r0, #1
     ba4:	b2c0      	uxtb	r0, r0
  EState = E1State | E2State;
     ba6:	4303      	orrs	r3, r0
     ba8:	7013      	strb	r3, [r2, #0]
  if (lastStateE != EState) {
     baa:	7822      	ldrb	r2, [r4, #0]
  E2State = digitalRead(E2Input) << 1;
     bac:	7008      	strb	r0, [r1, #0]
  if (lastStateE != EState) {
     bae:	4293      	cmp	r3, r2
     bb0:	d009      	beq.n	bc6 <encoderE()+0x42>
    switch (EState) {
     bb2:	2b03      	cmp	r3, #3
     bb4:	d807      	bhi.n	bc6 <encoderE()+0x42>
     bb6:	e8df f003 	tbb	[pc, r3]
     bba:	5e02      	.short	0x5e02
     bbc:	4c63      	.short	0x4c63
      case 0:
        if (lastStateE == 2) {
     bbe:	2a02      	cmp	r2, #2
     bc0:	d01d      	beq.n	bfe <encoderE()+0x7a>
          stepsE++;
          cwE = 1;
          EDialMoveRight = true;
          //EDialMoveLeft = false;
        }
        else if (lastStateE == 1) {
     bc2:	2a01      	cmp	r2, #1
     bc4:	d049      	beq.n	c5a <encoderE()+0xd6>
  }

  lastStateE = EState;


  if (EDialMoveRight == true)
     bc6:	4a37      	ldr	r2, [pc, #220]	; (ca4 <encoderE()+0x120>)
     bc8:	4937      	ldr	r1, [pc, #220]	; (ca8 <encoderE()+0x124>)
     bca:	7810      	ldrb	r0, [r2, #0]
  lastStateE = EState;
     bcc:	7023      	strb	r3, [r4, #0]
  if (EDialMoveRight == true)
     bce:	bb00      	cbnz	r0, c12 <encoderE()+0x8e>
    allButtons[ERotateRightButton] = 1;
    EDialMoveRight = false;
    EDialMoveLeft = false;
    ERightFalseCount = ERotateResetDelay;
  } else {
    if (ERightFalseCount != -1) {
     bd0:	4836      	ldr	r0, [pc, #216]	; (cac <encoderE()+0x128>)
     bd2:	6803      	ldr	r3, [r0, #0]
     bd4:	1c5c      	adds	r4, r3, #1
     bd6:	d036      	beq.n	c46 <encoderE()+0xc2>
      ERightFalseCount--;
     bd8:	3b01      	subs	r3, #1
    }
    if (ERightFalseCount <= 0) {
     bda:	2b00      	cmp	r3, #0
      ERightFalseCount--;
     bdc:	6003      	str	r3, [r0, #0]
    if (ERightFalseCount <= 0) {
     bde:	dd32      	ble.n	c46 <encoderE()+0xc2>
      allButtons[ERotateRightButton] = 0;
    }
  }
  if (EDialMoveLeft == true)
     be0:	780b      	ldrb	r3, [r1, #0]
     be2:	b313      	cbz	r3, c2a <encoderE()+0xa6>
  {
    allButtons[ERotateLeftButton] = 1;
    EDialMoveLeft = false;
    EDialMoveRight = false;
    ELeftFalseCount = ERotateResetDelay;
     be4:	4b32      	ldr	r3, [pc, #200]	; (cb0 <encoderE()+0x12c>)
    allButtons[ERotateLeftButton] = 1;
     be6:	4833      	ldr	r0, [pc, #204]	; (cb4 <encoderE()+0x130>)
    ELeftFalseCount = ERotateResetDelay;
     be8:	681d      	ldr	r5, [r3, #0]
     bea:	4b33      	ldr	r3, [pc, #204]	; (cb8 <encoderE()+0x134>)
    allButtons[ERotateLeftButton] = 1;
     bec:	4c33      	ldr	r4, [pc, #204]	; (cbc <encoderE()+0x138>)
     bee:	6800      	ldr	r0, [r0, #0]
    ELeftFalseCount = ERotateResetDelay;
     bf0:	601d      	str	r5, [r3, #0]
    EDialMoveLeft = false;
     bf2:	2300      	movs	r3, #0
     bf4:	700b      	strb	r3, [r1, #0]
    EDialMoveRight = false;
     bf6:	7013      	strb	r3, [r2, #0]
    allButtons[ERotateLeftButton] = 1;
     bf8:	2301      	movs	r3, #1
     bfa:	5423      	strb	r3, [r4, r0]
    }
    if (ELeftFalseCount <= 0) {
      allButtons[ERotateLeftButton] = 0;
    }
  }
}
     bfc:	bd38      	pop	{r3, r4, r5, pc}
          stepsE++;
     bfe:	4830      	ldr	r0, [pc, #192]	; (cc0 <encoderE()+0x13c>)
          cwE = 1;
     c00:	4d30      	ldr	r5, [pc, #192]	; (cc4 <encoderE()+0x140>)
          stepsE++;
     c02:	7802      	ldrb	r2, [r0, #0]
  lastStateE = EState;
     c04:	7023      	strb	r3, [r4, #0]
          stepsE++;
     c06:	1c53      	adds	r3, r2, #1
     c08:	7003      	strb	r3, [r0, #0]
          cwE = 1;
     c0a:	4a26      	ldr	r2, [pc, #152]	; (ca4 <encoderE()+0x120>)
     c0c:	4926      	ldr	r1, [pc, #152]	; (ca8 <encoderE()+0x124>)
     c0e:	2301      	movs	r3, #1
     c10:	602b      	str	r3, [r5, #0]
    ERightFalseCount = ERotateResetDelay;
     c12:	4b27      	ldr	r3, [pc, #156]	; (cb0 <encoderE()+0x12c>)
    allButtons[ERotateRightButton] = 1;
     c14:	482c      	ldr	r0, [pc, #176]	; (cc8 <encoderE()+0x144>)
    ERightFalseCount = ERotateResetDelay;
     c16:	681d      	ldr	r5, [r3, #0]
     c18:	4b24      	ldr	r3, [pc, #144]	; (cac <encoderE()+0x128>)
    allButtons[ERotateRightButton] = 1;
     c1a:	4c28      	ldr	r4, [pc, #160]	; (cbc <encoderE()+0x138>)
     c1c:	6800      	ldr	r0, [r0, #0]
    ERightFalseCount = ERotateResetDelay;
     c1e:	601d      	str	r5, [r3, #0]
    EDialMoveRight = false;
     c20:	2300      	movs	r3, #0
     c22:	7013      	strb	r3, [r2, #0]
    EDialMoveLeft = false;
     c24:	700b      	strb	r3, [r1, #0]
    allButtons[ERotateRightButton] = 1;
     c26:	2301      	movs	r3, #1
     c28:	5423      	strb	r3, [r4, r0]
    if (ELeftFalseCount != -1) {
     c2a:	4a23      	ldr	r2, [pc, #140]	; (cb8 <encoderE()+0x134>)
     c2c:	6813      	ldr	r3, [r2, #0]
     c2e:	1c59      	adds	r1, r3, #1
     c30:	d003      	beq.n	c3a <encoderE()+0xb6>
      ELeftFalseCount--;
     c32:	3b01      	subs	r3, #1
    if (ELeftFalseCount <= 0) {
     c34:	2b00      	cmp	r3, #0
      ELeftFalseCount--;
     c36:	6013      	str	r3, [r2, #0]
    if (ELeftFalseCount <= 0) {
     c38:	dce0      	bgt.n	bfc <encoderE()+0x78>
      allButtons[ERotateLeftButton] = 0;
     c3a:	4b1e      	ldr	r3, [pc, #120]	; (cb4 <encoderE()+0x130>)
     c3c:	4a1f      	ldr	r2, [pc, #124]	; (cbc <encoderE()+0x138>)
     c3e:	681b      	ldr	r3, [r3, #0]
     c40:	2100      	movs	r1, #0
     c42:	54d1      	strb	r1, [r2, r3]
}
     c44:	bd38      	pop	{r3, r4, r5, pc}
      allButtons[ERotateRightButton] = 0;
     c46:	4b20      	ldr	r3, [pc, #128]	; (cc8 <encoderE()+0x144>)
     c48:	481c      	ldr	r0, [pc, #112]	; (cbc <encoderE()+0x138>)
     c4a:	681b      	ldr	r3, [r3, #0]
     c4c:	2400      	movs	r4, #0
     c4e:	54c4      	strb	r4, [r0, r3]
     c50:	e7c6      	b.n	be0 <encoderE()+0x5c>
        if (lastStateE == 1) {
     c52:	2a01      	cmp	r2, #1
     c54:	d0d3      	beq.n	bfe <encoderE()+0x7a>
        else if (lastStateE == 2) {
     c56:	2a02      	cmp	r2, #2
     c58:	d1b5      	bne.n	bc6 <encoderE()+0x42>
          stepsE--;
     c5a:	4919      	ldr	r1, [pc, #100]	; (cc0 <encoderE()+0x13c>)
          cwE = -1;
     c5c:	4819      	ldr	r0, [pc, #100]	; (cc4 <encoderE()+0x140>)
          stepsE--;
     c5e:	780a      	ldrb	r2, [r1, #0]
     c60:	3a01      	subs	r2, #1
     c62:	700a      	strb	r2, [r1, #0]
          cwE = -1;
     c64:	f04f 35ff 	mov.w	r5, #4294967295
          EDialMoveLeft = true;
     c68:	490f      	ldr	r1, [pc, #60]	; (ca8 <encoderE()+0x124>)
  if (EDialMoveRight == true)
     c6a:	4a0e      	ldr	r2, [pc, #56]	; (ca4 <encoderE()+0x120>)
          cwE = -1;
     c6c:	6005      	str	r5, [r0, #0]
          EDialMoveLeft = true;
     c6e:	2001      	movs	r0, #1
     c70:	7008      	strb	r0, [r1, #0]
  if (EDialMoveRight == true)
     c72:	7810      	ldrb	r0, [r2, #0]
     c74:	e7aa      	b.n	bcc <encoderE()+0x48>
        if (lastStateE == 0) {
     c76:	2a00      	cmp	r2, #0
     c78:	d0c1      	beq.n	bfe <encoderE()+0x7a>
        else if (lastStateE == 3) {
     c7a:	2a03      	cmp	r2, #3
     c7c:	d1a3      	bne.n	bc6 <encoderE()+0x42>
     c7e:	e7ec      	b.n	c5a <encoderE()+0xd6>
        if (lastStateE == 3) {
     c80:	2a03      	cmp	r2, #3
     c82:	d0bc      	beq.n	bfe <encoderE()+0x7a>
        else if (lastStateE == 0) {
     c84:	2a00      	cmp	r2, #0
     c86:	d0e8      	beq.n	c5a <encoderE()+0xd6>
     c88:	e79d      	b.n	bc6 <encoderE()+0x42>
     c8a:	bf00      	nop
     c8c:	1fff099c 	.word	0x1fff099c
     c90:	1fff0b8f 	.word	0x1fff0b8f
     c94:	1fff099d 	.word	0x1fff099d
     c98:	1fff0b93 	.word	0x1fff0b93
     c9c:	1fff0bc8 	.word	0x1fff0bc8
     ca0:	1fff0b90 	.word	0x1fff0b90
     ca4:	1fff0b92 	.word	0x1fff0b92
     ca8:	1fff0b91 	.word	0x1fff0b91
     cac:	1fff09a4 	.word	0x1fff09a4
     cb0:	1fff09ac 	.word	0x1fff09ac
     cb4:	1fff09a8 	.word	0x1fff09a8
     cb8:	1fff09a0 	.word	0x1fff09a0
     cbc:	1fff0b94 	.word	0x1fff0b94
     cc0:	1fff0bec 	.word	0x1fff0bec
     cc4:	1fff0bc0 	.word	0x1fff0bc0
     cc8:	1fff09b0 	.word	0x1fff09b0

00000ccc <loop>:
void loop() {
     ccc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  encoderA();
     cd0:	f7ff fc46 	bl	560 <encoderA()>
  encoderB();
     cd4:	4d5e      	ldr	r5, [pc, #376]	; (e50 <loop+0x184>)
     cd6:	f8df 918c 	ldr.w	r9, [pc, #396]	; e64 <loop+0x198>
     cda:	4e5e      	ldr	r6, [pc, #376]	; (e54 <loop+0x188>)
     cdc:	4f5e      	ldr	r7, [pc, #376]	; (e58 <loop+0x18c>)
     cde:	f7ff fd2f 	bl	740 <encoderB()>
  for (int i = buttonInputStart; i < numButtons; i++) {
     ce2:	240a      	movs	r4, #10
  encoderC();
     ce4:	f7ff fe06 	bl	8f4 <encoderC()>
		else usb_joystick_data[0] &= ~(1 << button);
     ce8:	f04f 0801 	mov.w	r8, #1
  encoderD();
     cec:	f7ff fea6 	bl	a3c <encoderD()>
  encoderE();
     cf0:	f7ff ff48 	bl	b84 <encoderE()>
  for (int i = buttonInputStart; i < numButtons; i++) {
     cf4:	e002      	b.n	cfc <loop+0x30>
     cf6:	3401      	adds	r4, #1
     cf8:	2c1c      	cmp	r4, #28
     cfa:	d01a      	beq.n	d32 <loop+0x66>
    if (digitalRead(i)) {
     cfc:	b2e0      	uxtb	r0, r4
     cfe:	f000 fa67 	bl	11d0 <digitalRead>
    if (i != ledPin) {
     d02:	f8d9 3000 	ldr.w	r3, [r9]
    if (digitalRead(i)) {
     d06:	fab0 f280 	clz	r2, r0
     d0a:	0952      	lsrs	r2, r2, #5
    if (i != ledPin) {
     d0c:	429c      	cmp	r4, r3
    if (digitalRead(i)) {
     d0e:	f805 2f01 	strb.w	r2, [r5, #1]!
    if (i != ledPin) {
     d12:	d0f0      	beq.n	cf6 <loop+0x2a>
		if (val) usb_joystick_data[0] |= (1 << button);
     d14:	fa08 f304 	lsl.w	r3, r8, r4
     d18:	2800      	cmp	r0, #0
     d1a:	d160      	bne.n	dde <loop+0x112>
     d1c:	6832      	ldr	r2, [r6, #0]
     d1e:	4313      	orrs	r3, r2
		if (!manual_mode) usb_joystick_send();
     d20:	783a      	ldrb	r2, [r7, #0]
     d22:	6033      	str	r3, [r6, #0]
     d24:	2a00      	cmp	r2, #0
     d26:	d1e6      	bne.n	cf6 <loop+0x2a>
  for (int i = buttonInputStart; i < numButtons; i++) {
     d28:	3401      	adds	r4, #1
     d2a:	f001 f811 	bl	1d50 <usb_joystick_send>
     d2e:	2c1c      	cmp	r4, #28
     d30:	d1e4      	bne.n	cfc <loop+0x30>
  Joystick.button(29, !allButtons[24]);
     d32:	4d4a      	ldr	r5, [pc, #296]	; (e5c <loop+0x190>)
		if (val) usb_joystick_data[0] |= (1 << button);
     d34:	7e2b      	ldrb	r3, [r5, #24]
     d36:	2b00      	cmp	r3, #0
     d38:	f040 8081 	bne.w	e3e <loop+0x172>
     d3c:	6833      	ldr	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     d3e:	783a      	ldrb	r2, [r7, #0]
		if (val) usb_joystick_data[0] |= (1 << button);
     d40:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
     d44:	6033      	str	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     d46:	2a00      	cmp	r2, #0
     d48:	d06c      	beq.n	e24 <loop+0x158>
		if (val) usb_joystick_data[0] |= (1 << button);
     d4a:	7e69      	ldrb	r1, [r5, #25]
     d4c:	2900      	cmp	r1, #0
     d4e:	d170      	bne.n	e32 <loop+0x166>
     d50:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
     d54:	6033      	str	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     d56:	2a00      	cmp	r2, #0
     d58:	d057      	beq.n	e0a <loop+0x13e>
		if (val) usb_joystick_data[0] |= (1 << button);
     d5a:	7ea9      	ldrb	r1, [r5, #26]
     d5c:	2900      	cmp	r1, #0
     d5e:	d15b      	bne.n	e18 <loop+0x14c>
     d60:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
     d64:	6033      	str	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     d66:	2a00      	cmp	r2, #0
     d68:	d042      	beq.n	df0 <loop+0x124>
		if (val) usb_joystick_data[0] |= (1 << button);
     d6a:	7ee9      	ldrb	r1, [r5, #27]
     d6c:	2900      	cmp	r1, #0
     d6e:	d146      	bne.n	dfe <loop+0x132>
     d70:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     d74:	6033      	str	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     d76:	2a00      	cmp	r2, #0
     d78:	d037      	beq.n	dea <loop+0x11e>
  for (int i = buttonInputStart; i < numButtons; i++) {
     d7a:	2400      	movs	r4, #0
		else usb_joystick_data[0] &= ~(1 << button);
     d7c:	f04f 0801 	mov.w	r8, #1
     d80:	e007      	b.n	d92 <loop+0xc6>
		if (val) usb_joystick_data[0] |= (1 << button);
     d82:	6832      	ldr	r2, [r6, #0]
     d84:	4313      	orrs	r3, r2
		if (!manual_mode) usb_joystick_send();
     d86:	783a      	ldrb	r2, [r7, #0]
     d88:	6033      	str	r3, [r6, #0]
     d8a:	b1a2      	cbz	r2, db6 <loop+0xea>
  for (int i = 0; i < numEncoders * 2; i++)
     d8c:	3401      	adds	r4, #1
     d8e:	2c0a      	cmp	r4, #10
     d90:	d016      	beq.n	dc0 <loop+0xf4>
    if (i != ledPin) {
     d92:	f8d9 3000 	ldr.w	r3, [r9]
     d96:	42a3      	cmp	r3, r4
     d98:	d0f8      	beq.n	d8c <loop+0xc0>
		if (val) usb_joystick_data[0] |= (1 << button);
     d9a:	5d2a      	ldrb	r2, [r5, r4]
     d9c:	fa08 f304 	lsl.w	r3, r8, r4
     da0:	2a00      	cmp	r2, #0
     da2:	d1ee      	bne.n	d82 <loop+0xb6>
		else usb_joystick_data[0] &= ~(1 << button);
     da4:	6833      	ldr	r3, [r6, #0]
     da6:	fa08 f204 	lsl.w	r2, r8, r4
     daa:	ea23 0302 	bic.w	r3, r3, r2
		if (!manual_mode) usb_joystick_send();
     dae:	783a      	ldrb	r2, [r7, #0]
     db0:	6033      	str	r3, [r6, #0]
     db2:	2a00      	cmp	r2, #0
     db4:	d1ea      	bne.n	d8c <loop+0xc0>
  for (int i = 0; i < numEncoders * 2; i++)
     db6:	3401      	adds	r4, #1
     db8:	f000 ffca 	bl	1d50 <usb_joystick_send>
     dbc:	2c0a      	cmp	r4, #10
     dbe:	d1e8      	bne.n	d92 <loop+0xc6>
    prevButtons[i] = allButtons[i];
     dc0:	4d26      	ldr	r5, [pc, #152]	; (e5c <loop+0x190>)
     dc2:	4c27      	ldr	r4, [pc, #156]	; (e60 <loop+0x194>)
	}
	void send_now(void) {
		usb_joystick_send();
     dc4:	f000 ffc4 	bl	1d50 <usb_joystick_send>
     dc8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     dca:	c40f      	stmia	r4!, {r0, r1, r2, r3}
     dcc:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
     dd0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  delay(1);
     dd4:	2001      	movs	r0, #1
}
     dd6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  delay(1);
     dda:	f000 ba43 	b.w	1264 <delay>
		else usb_joystick_data[0] &= ~(1 << button);
     dde:	6833      	ldr	r3, [r6, #0]
     de0:	fa08 f204 	lsl.w	r2, r8, r4
     de4:	ea23 0302 	bic.w	r3, r3, r2
     de8:	e79a      	b.n	d20 <loop+0x54>
		if (!manual_mode) usb_joystick_send();
     dea:	f000 ffb1 	bl	1d50 <usb_joystick_send>
     dee:	e7c4      	b.n	d7a <loop+0xae>
     df0:	f000 ffae 	bl	1d50 <usb_joystick_send>
		if (val) usb_joystick_data[0] |= (1 << button);
     df4:	7ee9      	ldrb	r1, [r5, #27]
     df6:	6833      	ldr	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     df8:	783a      	ldrb	r2, [r7, #0]
		if (val) usb_joystick_data[0] |= (1 << button);
     dfa:	2900      	cmp	r1, #0
     dfc:	d0b8      	beq.n	d70 <loop+0xa4>
		else usb_joystick_data[0] &= ~(1 << button);
     dfe:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
     e02:	6033      	str	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     e04:	2a00      	cmp	r2, #0
     e06:	d1b8      	bne.n	d7a <loop+0xae>
     e08:	e7ef      	b.n	dea <loop+0x11e>
     e0a:	f000 ffa1 	bl	1d50 <usb_joystick_send>
		if (val) usb_joystick_data[0] |= (1 << button);
     e0e:	7ea9      	ldrb	r1, [r5, #26]
     e10:	6833      	ldr	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     e12:	783a      	ldrb	r2, [r7, #0]
		if (val) usb_joystick_data[0] |= (1 << button);
     e14:	2900      	cmp	r1, #0
     e16:	d0a3      	beq.n	d60 <loop+0x94>
		else usb_joystick_data[0] &= ~(1 << button);
     e18:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
     e1c:	6033      	str	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     e1e:	2a00      	cmp	r2, #0
     e20:	d1a3      	bne.n	d6a <loop+0x9e>
     e22:	e7e5      	b.n	df0 <loop+0x124>
     e24:	f000 ff94 	bl	1d50 <usb_joystick_send>
		if (val) usb_joystick_data[0] |= (1 << button);
     e28:	7e69      	ldrb	r1, [r5, #25]
     e2a:	6833      	ldr	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     e2c:	783a      	ldrb	r2, [r7, #0]
		if (val) usb_joystick_data[0] |= (1 << button);
     e2e:	2900      	cmp	r1, #0
     e30:	d08e      	beq.n	d50 <loop+0x84>
		else usb_joystick_data[0] &= ~(1 << button);
     e32:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
     e36:	6033      	str	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     e38:	2a00      	cmp	r2, #0
     e3a:	d18e      	bne.n	d5a <loop+0x8e>
     e3c:	e7e5      	b.n	e0a <loop+0x13e>
		else usb_joystick_data[0] &= ~(1 << button);
     e3e:	6833      	ldr	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     e40:	783a      	ldrb	r2, [r7, #0]
		else usb_joystick_data[0] &= ~(1 << button);
     e42:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     e46:	6033      	str	r3, [r6, #0]
		if (!manual_mode) usb_joystick_send();
     e48:	2a00      	cmp	r2, #0
     e4a:	f47f af7e 	bne.w	d4a <loop+0x7e>
     e4e:	e7e9      	b.n	e24 <loop+0x158>
     e50:	1fff0b9d 	.word	0x1fff0b9d
     e54:	1fff0cfc 	.word	0x1fff0cfc
     e58:	1fff0cf9 	.word	0x1fff0cf9
     e5c:	1fff0b94 	.word	0x1fff0b94
     e60:	1fff0bcc 	.word	0x1fff0bcc
     e64:	1fff09b4 	.word	0x1fff09b4

00000e68 <Print::println()>:
{
     e68:	b500      	push	{lr}
	return write(buf, 2);
     e6a:	6803      	ldr	r3, [r0, #0]
{
     e6c:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
     e6e:	f640 220d 	movw	r2, #2573	; 0xa0d
     e72:	f8ad 2004 	strh.w	r2, [sp, #4]
	return write(buf, 2);
     e76:	685b      	ldr	r3, [r3, #4]
     e78:	2202      	movs	r2, #2
     e7a:	a901      	add	r1, sp, #4
     e7c:	4798      	blx	r3
}
     e7e:	b003      	add	sp, #12
     e80:	f85d fb04 	ldr.w	pc, [sp], #4

00000e84 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
     e84:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
     e86:	f7ff fae7 	bl	458 <setup>
	while (1) {
		loop();
     e8a:	f7ff ff1f 	bl	ccc <loop>
		yield();
     e8e:	f001 f953 	bl	2138 <yield>
	while (1) {
     e92:	e7fa      	b.n	e8a <main+0x6>

00000e94 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
     e94:	b401      	push	{r0}
#endif
	orr	r3, r1, r0
     e96:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
     e9a:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
     e9e:	d16f      	bne.n	f80 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
     ea0:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
     ea2:	d341      	bcc.n	f28 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
     ea4:	f851 3b04 	ldr.w	r3, [r1], #4
     ea8:	f840 3b04 	str.w	r3, [r0], #4
     eac:	f851 3b04 	ldr.w	r3, [r1], #4
     eb0:	f840 3b04 	str.w	r3, [r0], #4
     eb4:	f851 3b04 	ldr.w	r3, [r1], #4
     eb8:	f840 3b04 	str.w	r3, [r0], #4
     ebc:	f851 3b04 	ldr.w	r3, [r1], #4
     ec0:	f840 3b04 	str.w	r3, [r0], #4
     ec4:	f851 3b04 	ldr.w	r3, [r1], #4
     ec8:	f840 3b04 	str.w	r3, [r0], #4
     ecc:	f851 3b04 	ldr.w	r3, [r1], #4
     ed0:	f840 3b04 	str.w	r3, [r0], #4
     ed4:	f851 3b04 	ldr.w	r3, [r1], #4
     ed8:	f840 3b04 	str.w	r3, [r0], #4
     edc:	f851 3b04 	ldr.w	r3, [r1], #4
     ee0:	f840 3b04 	str.w	r3, [r0], #4
     ee4:	f851 3b04 	ldr.w	r3, [r1], #4
     ee8:	f840 3b04 	str.w	r3, [r0], #4
     eec:	f851 3b04 	ldr.w	r3, [r1], #4
     ef0:	f840 3b04 	str.w	r3, [r0], #4
     ef4:	f851 3b04 	ldr.w	r3, [r1], #4
     ef8:	f840 3b04 	str.w	r3, [r0], #4
     efc:	f851 3b04 	ldr.w	r3, [r1], #4
     f00:	f840 3b04 	str.w	r3, [r0], #4
     f04:	f851 3b04 	ldr.w	r3, [r1], #4
     f08:	f840 3b04 	str.w	r3, [r0], #4
     f0c:	f851 3b04 	ldr.w	r3, [r1], #4
     f10:	f840 3b04 	str.w	r3, [r0], #4
     f14:	f851 3b04 	ldr.w	r3, [r1], #4
     f18:	f840 3b04 	str.w	r3, [r0], #4
     f1c:	f851 3b04 	ldr.w	r3, [r1], #4
     f20:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
     f24:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
     f26:	d2bd      	bcs.n	ea4 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
     f28:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
     f2a:	d311      	bcc.n	f50 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
     f2c:	f851 3b04 	ldr.w	r3, [r1], #4
     f30:	f840 3b04 	str.w	r3, [r0], #4
     f34:	f851 3b04 	ldr.w	r3, [r1], #4
     f38:	f840 3b04 	str.w	r3, [r0], #4
     f3c:	f851 3b04 	ldr.w	r3, [r1], #4
     f40:	f840 3b04 	str.w	r3, [r0], #4
     f44:	f851 3b04 	ldr.w	r3, [r1], #4
     f48:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
     f4c:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
     f4e:	d2ed      	bcs.n	f2c <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
     f50:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
     f52:	d305      	bcc.n	f60 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
     f54:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
     f58:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
     f5c:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
     f5e:	d2f9      	bcs.n	f54 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
     f60:	3204      	adds	r2, #4
	beq	.Ldone
     f62:	d00a      	beq.n	f7a <memcpy+0xe6>

	lsls	r2, r2, #31
     f64:	07d2      	lsls	r2, r2, #31
	itt ne
     f66:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
     f68:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
     f6c:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
     f70:	d303      	bcc.n	f7a <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
     f72:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
     f74:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
     f76:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
     f78:	7043      	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
     f7a:	bc01      	pop	{r0}
#endif
	bx	lr
     f7c:	4770      	bx	lr
     f7e:	bf00      	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
     f80:	2a0c      	cmp	r2, #12
	blo	.Lbyte_copy
     f82:	d34a      	bcc.n	101a <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
     f84:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
     f88:	d011      	beq.n	fae <memcpy+0x11a>

	rsb	r3, #4
     f8a:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
     f8e:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
     f90:	07db      	lsls	r3, r3, #31
	itt ne
     f92:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
     f94:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
     f98:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
     f9c:	d307      	bcc.n	fae <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
     f9e:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
     fa2:	f800 3b01 	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
     fa6:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
     faa:	f800 3b01 	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
     fae:	f011 0303 	ands.w	r3, r1, #3
	beq	.Lbig_block
     fb2:	f43f af75 	beq.w	ea0 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
     fb6:	b430      	push	{r4, r5}
	subs	r2, #4
     fb8:	3a04      	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
     fba:	1ac9      	subs	r1, r1, r3
	rsb	ip, r3, #4
     fbc:	f1c3 0c04 	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
     fc0:	f851 4b04 	ldr.w	r4, [r1], #4

	cmp	r3, #2
     fc4:	2b02      	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
     fc6:	d019      	beq.n	ffc <memcpy+0x168>
	cmp	r3, #3
     fc8:	2b03      	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
     fca:	d00b      	beq.n	fe4 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
     fcc:	0a24      	lsrs	r4, r4, #8
     fce:	f851 3b04 	ldr.w	r3, [r1], #4
     fd2:	061d      	lsls	r5, r3, #24
     fd4:	ea44 0405 	orr.w	r4, r4, r5
     fd8:	f840 4b04 	str.w	r4, [r0], #4
     fdc:	461c      	mov	r4, r3
     fde:	3a04      	subs	r2, #4
     fe0:	d2f4      	bcs.n	fcc <memcpy+0x138>
	b	.Lsrc_misaligned_tail
     fe2:	e016      	b.n	1012 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
     fe4:	0e24      	lsrs	r4, r4, #24
     fe6:	f851 3b04 	ldr.w	r3, [r1], #4
     fea:	021d      	lsls	r5, r3, #8
     fec:	ea44 0405 	orr.w	r4, r4, r5
     ff0:	f840 4b04 	str.w	r4, [r0], #4
     ff4:	461c      	mov	r4, r3
     ff6:	3a04      	subs	r2, #4
     ff8:	d2f4      	bcs.n	fe4 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
     ffa:	e00a      	b.n	1012 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
     ffc:	0c24      	lsrs	r4, r4, #16
     ffe:	f851 3b04 	ldr.w	r3, [r1], #4
    1002:	041d      	lsls	r5, r3, #16
    1004:	ea44 0405 	orr.w	r4, r4, r5
    1008:	f840 4b04 	str.w	r4, [r0], #4
    100c:	461c      	mov	r4, r3
    100e:	3a04      	subs	r2, #4
    1010:	d2f4      	bcs.n	ffc <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    1012:	3204      	adds	r2, #4
	subs	r1, ip
    1014:	ebb1 010c 	subs.w	r1, r1, ip
	pop	{r4, r5}
    1018:	bc30      	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    101a:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    101c:	d3a0      	bcc.n	f60 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    101e:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    1020:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    1024:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    1028:	d2f9      	bcs.n	101e <memcpy+0x18a>

	ldrb	r3, [r1]
    102a:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    102c:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    102e:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    1030:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    1032:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    1034:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    1036:	bc01      	pop	{r0}
#endif
	bx	lr
    1038:	4770      	bx	lr
    103a:	bf00      	nop

0000103c <fault_isr>:
{
    103c:	b508      	push	{r3, lr}
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    103e:	4c0f      	ldr	r4, [pc, #60]	; (107c <fault_isr+0x40>)
    1040:	6b63      	ldr	r3, [r4, #52]	; 0x34
    1042:	0358      	lsls	r0, r3, #13
    1044:	d40d      	bmi.n	1062 <fault_isr+0x26>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    1046:	6b63      	ldr	r3, [r4, #52]	; 0x34
    1048:	0559      	lsls	r1, r3, #21
    104a:	d40f      	bmi.n	106c <fault_isr+0x30>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    104c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    104e:	051a      	lsls	r2, r3, #20
    1050:	d411      	bmi.n	1076 <fault_isr+0x3a>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    1052:	6b63      	ldr	r3, [r4, #52]	; 0x34
    1054:	04db      	lsls	r3, r3, #19
    1056:	d5f3      	bpl.n	1040 <fault_isr+0x4>
    1058:	f000 f812 	bl	1080 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    105c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    105e:	0358      	lsls	r0, r3, #13
    1060:	d5f1      	bpl.n	1046 <fault_isr+0xa>
    1062:	f000 fa07 	bl	1474 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    1066:	6b63      	ldr	r3, [r4, #52]	; 0x34
    1068:	0559      	lsls	r1, r3, #21
    106a:	d5ef      	bpl.n	104c <fault_isr+0x10>
    106c:	f000 f808 	bl	1080 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    1070:	6b63      	ldr	r3, [r4, #52]	; 0x34
    1072:	051a      	lsls	r2, r3, #20
    1074:	d5ed      	bpl.n	1052 <fault_isr+0x16>
    1076:	f000 f803 	bl	1080 <unused_isr>
    107a:	e7ea      	b.n	1052 <fault_isr+0x16>
    107c:	40048000 	.word	0x40048000

00001080 <unused_isr>:
{
    1080:	b508      	push	{r3, lr}
	fault_isr();
    1082:	f7ff ffdb 	bl	103c <fault_isr>
    1086:	bf00      	nop

00001088 <startup_early_hook>:
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    1088:	4b01      	ldr	r3, [pc, #4]	; (1090 <startup_early_hook+0x8>)
    108a:	2210      	movs	r2, #16
    108c:	801a      	strh	r2, [r3, #0]
}
    108e:	4770      	bx	lr
    1090:	40052000 	.word	0x40052000

00001094 <startup_late_hook>:
static void startup_default_late_hook(void) {}
    1094:	4770      	bx	lr
    1096:	bf00      	nop

00001098 <ultoa>:


char * ultoa(unsigned long val, char *buf, int radix)
{
	unsigned digit;
	int i=0, j;
    1098:	f101 3cff 	add.w	ip, r1, #4294967295
{
    109c:	b570      	push	{r4, r5, r6, lr}
	char t;

	while (1) {
		digit = val % radix;
    109e:	4665      	mov	r5, ip
	int i=0, j;
    10a0:	2400      	movs	r4, #0
    10a2:	e001      	b.n	10a8 <ultoa+0x10>
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
    10a4:	4670      	mov	r0, lr
		if (val == 0) break;
		i++;
    10a6:	3401      	adds	r4, #1
		digit = val % radix;
    10a8:	fbb0 fef2 	udiv	lr, r0, r2
    10ac:	fb02 031e 	mls	r3, r2, lr, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    10b0:	2b09      	cmp	r3, #9
    10b2:	f103 0630 	add.w	r6, r3, #48	; 0x30
    10b6:	bf8a      	itet	hi
    10b8:	3337      	addhi	r3, #55	; 0x37
    10ba:	b2f3      	uxtbls	r3, r6
    10bc:	b2db      	uxtbhi	r3, r3
		if (val == 0) break;
    10be:	4290      	cmp	r0, r2
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    10c0:	f805 3f01 	strb.w	r3, [r5, #1]!
		if (val == 0) break;
    10c4:	d2ee      	bcs.n	10a4 <ultoa+0xc>
	}
	buf[i + 1] = 0;
    10c6:	1c63      	adds	r3, r4, #1
    10c8:	2200      	movs	r2, #0
    10ca:	54ca      	strb	r2, [r1, r3]
    10cc:	18c8      	adds	r0, r1, r3
	for (j=0; j < i; j++, i--) {
    10ce:	b17c      	cbz	r4, 10f0 <ultoa+0x58>
		t = buf[j];
    10d0:	4662      	mov	r2, ip
    10d2:	f81c 5f01 	ldrb.w	r5, [ip, #1]!
		buf[j] = buf[i];
    10d6:	f810 ed01 	ldrb.w	lr, [r0, #-1]!
    10da:	f88c e000 	strb.w	lr, [ip]
	for (j=0; j < i; j++, i--) {
    10de:	eba1 030c 	sub.w	r3, r1, ip
    10e2:	3202      	adds	r2, #2
    10e4:	3b01      	subs	r3, #1
    10e6:	1a52      	subs	r2, r2, r1
    10e8:	4423      	add	r3, r4
    10ea:	429a      	cmp	r2, r3
		buf[i] = t;
    10ec:	7005      	strb	r5, [r0, #0]
	for (j=0; j < i; j++, i--) {
    10ee:	dbef      	blt.n	10d0 <ultoa+0x38>
	}
	return buf;
}
    10f0:	4608      	mov	r0, r1
    10f2:	bd70      	pop	{r4, r5, r6, pc}

000010f4 <rtc_set>:
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    10f4:	4b03      	ldr	r3, [pc, #12]	; (1104 <rtc_set+0x10>)
    10f6:	2200      	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    10f8:	2110      	movs	r1, #16
	RTC_SR = 0;
    10fa:	615a      	str	r2, [r3, #20]
	RTC_TPR = 0;
    10fc:	605a      	str	r2, [r3, #4]
	RTC_TSR = t;
    10fe:	6018      	str	r0, [r3, #0]
	RTC_SR = RTC_SR_TCE;
    1100:	6159      	str	r1, [r3, #20]
}
    1102:	4770      	bx	lr
    1104:	4003d000 	.word	0x4003d000

00001108 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    1108:	4770      	bx	lr
    110a:	bf00      	nop

0000110c <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    110c:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
{
    1110:	b5f0      	push	{r4, r5, r6, r7, lr}
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    1112:	f04f 6e00 	mov.w	lr, #134217728	; 0x8000000
    1116:	f8cc e104 	str.w	lr, [ip, #260]	; 0x104
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    111a:	f04f 5e80 	mov.w	lr, #268435456	; 0x10000000
    111e:	f8cc e104 	str.w	lr, [ip, #260]	; 0x104
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    1122:	f04f 5e00 	mov.w	lr, #536870912	; 0x20000000
    1126:	f8cc e104 	str.w	lr, [ip, #260]	; 0x104
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    112a:	4a24      	ldr	r2, [pc, #144]	; (11bc <_init_Teensyduino_internal_+0xb0>)
	FTM0_CNT = 0;
    112c:	4924      	ldr	r1, [pc, #144]	; (11c0 <_init_Teensyduino_internal_+0xb4>)
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    112e:	4825      	ldr	r0, [pc, #148]	; (11c4 <_init_Teensyduino_internal_+0xb8>)
	FTM1_CNT = 0;
    1130:	4c25      	ldr	r4, [pc, #148]	; (11c8 <_init_Teensyduino_internal_+0xbc>)
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    1132:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
    1136:	f8cc e104 	str.w	lr, [ip, #260]	; 0x104
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    113a:	2328      	movs	r3, #40	; 0x28
	FTM0_CNT = 0;
    113c:	2700      	movs	r7, #0
	FTM0_MOD = DEFAULT_FTM_MOD;
    113e:	f64e 76ff 	movw	r6, #61439	; 0xefff
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    1142:	2509      	movs	r5, #9
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    1144:	f04f 4e00 	mov.w	lr, #2147483648	; 0x80000000
    1148:	f8cc e104 	str.w	lr, [ip, #260]	; 0x104
{
    114c:	b083      	sub	sp, #12
	FTM0_CNT = 0;
    114e:	604f      	str	r7, [r1, #4]
	FTM0_MOD = DEFAULT_FTM_MOD;
    1150:	608e      	str	r6, [r1, #8]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    1152:	60cb      	str	r3, [r1, #12]
	FTM0_C1SC = 0x28;
    1154:	614b      	str	r3, [r1, #20]
	FTM0_C2SC = 0x28;
    1156:	61cb      	str	r3, [r1, #28]
	FTM0_C3SC = 0x28;
    1158:	624b      	str	r3, [r1, #36]	; 0x24
	FTM0_C4SC = 0x28;
    115a:	62cb      	str	r3, [r1, #44]	; 0x2c
	FTM0_C5SC = 0x28;
    115c:	634b      	str	r3, [r1, #52]	; 0x34
	FTM0_C6SC = 0x28;
    115e:	63cb      	str	r3, [r1, #60]	; 0x3c
	FTM0_C7SC = 0x28;
    1160:	644b      	str	r3, [r1, #68]	; 0x44
	FTM3_C0SC = 0x28;
    1162:	60d3      	str	r3, [r2, #12]
	FTM3_C1SC = 0x28;
    1164:	6153      	str	r3, [r2, #20]
	FTM3_C2SC = 0x28;
    1166:	61d3      	str	r3, [r2, #28]
	FTM3_C3SC = 0x28;
    1168:	6253      	str	r3, [r2, #36]	; 0x24
	FTM3_C4SC = 0x28;
    116a:	62d3      	str	r3, [r2, #44]	; 0x2c
	FTM3_C5SC = 0x28;
    116c:	6353      	str	r3, [r2, #52]	; 0x34
	FTM3_C6SC = 0x28;
    116e:	63d3      	str	r3, [r2, #60]	; 0x3c
	FTM3_C7SC = 0x28;
    1170:	6453      	str	r3, [r2, #68]	; 0x44
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    1172:	600d      	str	r5, [r1, #0]
	FTM1_CNT = 0;
    1174:	6067      	str	r7, [r4, #4]
	FTM1_MOD = DEFAULT_FTM_MOD;
    1176:	60a6      	str	r6, [r4, #8]
	FTM1_C0SC = 0x28;
    1178:	60e3      	str	r3, [r4, #12]
	FTM1_C1SC = 0x28;
    117a:	6163      	str	r3, [r4, #20]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    117c:	6025      	str	r5, [r4, #0]
	FTM2_CNT = 0;
    117e:	6047      	str	r7, [r0, #4]
	FTM2_MOD = DEFAULT_FTM_MOD;
    1180:	6086      	str	r6, [r0, #8]
	FTM2_C0SC = 0x28;
    1182:	60c3      	str	r3, [r0, #12]
	FTM2_C1SC = 0x28;
    1184:	6143      	str	r3, [r0, #20]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    1186:	6005      	str	r5, [r0, #0]
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    1188:	6057      	str	r7, [r2, #4]
	FTM3_MOD = DEFAULT_FTM_MOD;
    118a:	6096      	str	r6, [r2, #8]
	FTM3_C0SC = 0x28;
    118c:	60d3      	str	r3, [r2, #12]
	FTM3_C1SC = 0x28;
    118e:	6153      	str	r3, [r2, #20]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    1190:	6015      	str	r5, [r2, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
    1192:	f001 f875 	bl	2280 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    1196:	f7ff ffb7 	bl	1108 <startup_middle_hook>
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
    119a:	4c0c      	ldr	r4, [pc, #48]	; (11cc <_init_Teensyduino_internal_+0xc0>)
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    119c:	6823      	ldr	r3, [r4, #0]
    119e:	9300      	str	r3, [sp, #0]
	return ret;
    11a0:	9b00      	ldr	r3, [sp, #0]
    11a2:	2b13      	cmp	r3, #19
    11a4:	d9fa      	bls.n	119c <_init_Teensyduino_internal_+0x90>
	usb_init();
    11a6:	f000 fd3b 	bl	1c20 <usb_init>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    11aa:	6823      	ldr	r3, [r4, #0]
    11ac:	9301      	str	r3, [sp, #4]
	return ret;
    11ae:	9b01      	ldr	r3, [sp, #4]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
    11b0:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    11b4:	d3f9      	bcc.n	11aa <_init_Teensyduino_internal_+0x9e>
}
    11b6:	b003      	add	sp, #12
    11b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    11ba:	bf00      	nop
    11bc:	400b9000 	.word	0x400b9000
    11c0:	40038000 	.word	0x40038000
    11c4:	400b8000 	.word	0x400b8000
    11c8:	40039000 	.word	0x40039000
    11cc:	1fff0bf0 	.word	0x1fff0bf0

000011d0 <digitalRead>:
#endif
}

uint8_t digitalRead(uint8_t pin)
{
	if (pin >= CORE_NUM_DIGITAL) return 0;
    11d0:	283f      	cmp	r0, #63	; 0x3f
    11d2:	d806      	bhi.n	11e2 <digitalRead+0x12>
#ifdef KINETISK
	return *portInputRegister(pin);
    11d4:	4b04      	ldr	r3, [pc, #16]	; (11e8 <digitalRead+0x18>)
    11d6:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
    11da:	f893 0200 	ldrb.w	r0, [r3, #512]	; 0x200
    11de:	b2c0      	uxtb	r0, r0
    11e0:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return 0;
    11e2:	2000      	movs	r0, #0
#else
	return (*portInputRegister(pin) & digitalPinToBitMask(pin)) ? 1 : 0;
#endif
}
    11e4:	4770      	bx	lr
    11e6:	bf00      	nop
    11e8:	000025a0 	.word	0x000025a0

000011ec <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    11ec:	283f      	cmp	r0, #63	; 0x3f
    11ee:	d820      	bhi.n	1232 <pinMode+0x46>
	config = portConfigRegister(pin);
    11f0:	4a1b      	ldr	r2, [pc, #108]	; (1260 <pinMode+0x74>)
    11f2:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    11f6:	2901      	cmp	r1, #1
	config = portConfigRegister(pin);
    11f8:	685b      	ldr	r3, [r3, #4]
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    11fa:	d00f      	beq.n	121c <pinMode+0x30>
    11fc:	2904      	cmp	r1, #4
    11fe:	d01d      	beq.n	123c <pinMode+0x50>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    1200:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
    1204:	2200      	movs	r2, #0
    1206:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    120a:	b199      	cbz	r1, 1234 <pinMode+0x48>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    120c:	2902      	cmp	r1, #2
    120e:	d022      	beq.n	1256 <pinMode+0x6a>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    1210:	2903      	cmp	r1, #3
    1212:	d10d      	bne.n	1230 <pinMode+0x44>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    1214:	f44f 7281 	mov.w	r2, #258	; 0x102
    1218:	601a      	str	r2, [r3, #0]
    121a:	4770      	bx	lr
		*portModeRegister(pin) = 1;
    121c:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1220:	f44f 72a2 	mov.w	r2, #324	; 0x144
		*portModeRegister(pin) = 1;
    1224:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1228:	601a      	str	r2, [r3, #0]
		    *config &= ~PORT_PCR_ODE;
    122a:	681a      	ldr	r2, [r3, #0]
    122c:	f022 0220 	bic.w	r2, r2, #32
    1230:	601a      	str	r2, [r3, #0]
		} else { // INPUT_DISABLE
			*config = 0;
		}
	}
}
    1232:	4770      	bx	lr
			*config = PORT_PCR_MUX(1);
    1234:	f44f 7280 	mov.w	r2, #256	; 0x100
    1238:	601a      	str	r2, [r3, #0]
    123a:	4770      	bx	lr
		*portModeRegister(pin) = 1;
    123c:	f852 1030 	ldr.w	r1, [r2, r0, lsl #3]
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1240:	f44f 72a2 	mov.w	r2, #324	; 0x144
		*portModeRegister(pin) = 1;
    1244:	2001      	movs	r0, #1
    1246:	f881 0280 	strb.w	r0, [r1, #640]	; 0x280
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    124a:	601a      	str	r2, [r3, #0]
		    *config |= PORT_PCR_ODE;
    124c:	681a      	ldr	r2, [r3, #0]
    124e:	f042 0220 	orr.w	r2, r2, #32
    1252:	601a      	str	r2, [r3, #0]
    1254:	4770      	bx	lr
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    1256:	f240 1203 	movw	r2, #259	; 0x103
    125a:	601a      	str	r2, [r3, #0]
    125c:	4770      	bx	lr
    125e:	bf00      	nop
    1260:	000025a0 	.word	0x000025a0

00001264 <delay>:
#endif
	return count * 1000 + current / (F_CPU / 1000000);
}

void delay(uint32_t ms)
{
    1264:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1268:	4604      	mov	r4, r0
	__disable_irq();
    126a:	b672      	cpsid	i
	count = systick_millis_count;
    126c:	4f20      	ldr	r7, [pc, #128]	; (12f0 <delay+0x8c>)
	current = SYST_CVR;
    126e:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    1272:	6993      	ldr	r3, [r2, #24]
	count = systick_millis_count;
    1274:	683d      	ldr	r5, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    1276:	f8d2 2d04 	ldr.w	r2, [r2, #3332]	; 0xd04
	__enable_irq();
    127a:	b662      	cpsie	i
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    127c:	0152      	lsls	r2, r2, #5
    127e:	d502      	bpl.n	1286 <delay+0x22>
    1280:	2b32      	cmp	r3, #50	; 0x32
    1282:	bf88      	it	hi
    1284:	3501      	addhi	r5, #1
	uint32_t start = micros();

	if (ms > 0) {
    1286:	b90c      	cbnz	r4, 128c <delay+0x28>
				start += 1000;
			}
			yield();
		}
	}
}
    1288:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	current = ((F_CPU / 1000) - 1) - current;
    128c:	f8df 9064 	ldr.w	r9, [pc, #100]	; 12f4 <delay+0x90>
	return count * 1000 + current / (F_CPU / 1000000);
    1290:	f8df 8064 	ldr.w	r8, [pc, #100]	; 12f8 <delay+0x94>
	current = ((F_CPU / 1000) - 1) - current;
    1294:	eba9 0303 	sub.w	r3, r9, r3
	return count * 1000 + current / (F_CPU / 1000000);
    1298:	fba8 2303 	umull	r2, r3, r8, r3
    129c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    12a0:	fb02 f505 	mul.w	r5, r2, r5
    12a4:	eb05 1593 	add.w	r5, r5, r3, lsr #6
	current = SYST_CVR;
    12a8:	f04f 26e0 	mov.w	r6, #3758153728	; 0xe000e000
	__disable_irq();
    12ac:	b672      	cpsid	i
	current = SYST_CVR;
    12ae:	69b1      	ldr	r1, [r6, #24]
	count = systick_millis_count;
    12b0:	683a      	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    12b2:	f8d6 cd04 	ldr.w	ip, [r6, #3332]	; 0xd04
	__enable_irq();
    12b6:	b662      	cpsie	i
	current = ((F_CPU / 1000) - 1) - current;
    12b8:	eba9 0301 	sub.w	r3, r9, r1
	return count * 1000 + current / (F_CPU / 1000000);
    12bc:	fba8 0303 	umull	r0, r3, r8, r3
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    12c0:	f01c 6f80 	tst.w	ip, #67108864	; 0x4000000
			while ((micros() - start) >= 1000) {
    12c4:	ebc5 1393 	rsb	r3, r5, r3, lsr #6
	return count * 1000 + current / (F_CPU / 1000000);
    12c8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    12cc:	d002      	beq.n	12d4 <delay+0x70>
    12ce:	2932      	cmp	r1, #50	; 0x32
    12d0:	bf88      	it	hi
    12d2:	3201      	addhi	r2, #1
			while ((micros() - start) >= 1000) {
    12d4:	fb00 3302 	mla	r3, r0, r2, r3
    12d8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    12dc:	d304      	bcc.n	12e8 <delay+0x84>
				if (ms == 0) return;
    12de:	3c01      	subs	r4, #1
    12e0:	d0d2      	beq.n	1288 <delay+0x24>
				start += 1000;
    12e2:	f505 757a 	add.w	r5, r5, #1000	; 0x3e8
    12e6:	e7e1      	b.n	12ac <delay+0x48>
			yield();
    12e8:	f000 ff26 	bl	2138 <yield>
			while ((micros() - start) >= 1000) {
    12ec:	e7de      	b.n	12ac <delay+0x48>
    12ee:	bf00      	nop
    12f0:	1fff0bf0 	.word	0x1fff0bf0
    12f4:	0001d4bf 	.word	0x0001d4bf
    12f8:	88888889 	.word	0x88888889

000012fc <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    12fc:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    12fe:	2b04      	cmp	r3, #4
    1300:	d816      	bhi.n	1330 <usb_rx+0x34>
	__disable_irq();
    1302:	b672      	cpsid	i
	ret = rx_first[endpoint];
    1304:	490b      	ldr	r1, [pc, #44]	; (1334 <usb_rx+0x38>)
    1306:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    130a:	b178      	cbz	r0, 132c <usb_rx+0x30>
{
    130c:	b430      	push	{r4, r5}
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    130e:	4c0a      	ldr	r4, [pc, #40]	; (1338 <usb_rx+0x3c>)
    1310:	f8b0 c000 	ldrh.w	ip, [r0]
    1314:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
		rx_first[endpoint] = ret->next;
    1318:	6845      	ldr	r5, [r0, #4]
    131a:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    131e:	eba2 020c 	sub.w	r2, r2, ip
    1322:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    1326:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    1328:	bc30      	pop	{r4, r5}
    132a:	4770      	bx	lr
	__enable_irq();
    132c:	b662      	cpsie	i
}
    132e:	4770      	bx	lr
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    1330:	2000      	movs	r0, #0
    1332:	4770      	bx	lr
    1334:	1fff0c84 	.word	0x1fff0c84
    1338:	1fff0ce4 	.word	0x1fff0ce4

0000133c <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    133c:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    133e:	2804      	cmp	r0, #4
    1340:	d80b      	bhi.n	135a <usb_tx_packet_count+0x1e>
	__disable_irq();
    1342:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    1344:	4b07      	ldr	r3, [pc, #28]	; (1364 <usb_tx_packet_count+0x28>)
    1346:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    134a:	b143      	cbz	r3, 135e <usb_tx_packet_count+0x22>
	uint32_t count=0;
    134c:	2000      	movs	r0, #0
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    134e:	685b      	ldr	r3, [r3, #4]
    1350:	3001      	adds	r0, #1
    1352:	2b00      	cmp	r3, #0
    1354:	d1fb      	bne.n	134e <usb_tx_packet_count+0x12>
	__enable_irq();
    1356:	b662      	cpsie	i
	return count;
    1358:	4770      	bx	lr
	if (endpoint >= NUM_ENDPOINTS) return 0;
    135a:	2000      	movs	r0, #0
}
    135c:	4770      	bx	lr
	uint32_t count=0;
    135e:	4618      	mov	r0, r3
    1360:	e7f9      	b.n	1356 <usb_tx_packet_count+0x1a>
    1362:	bf00      	nop
    1364:	1fff0cb4 	.word	0x1fff0cb4

00001368 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    1368:	b410      	push	{r4}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    136a:	b672      	cpsid	i
	cfg = usb_endpoint_config_table;
    136c:	4a1a      	ldr	r2, [pc, #104]	; (13d8 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    136e:	4c1b      	ldr	r4, [pc, #108]	; (13dc <usb_rx_memory+0x74>)
	__disable_irq();
    1370:	2304      	movs	r3, #4
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    1372:	f812 1b01 	ldrb.w	r1, [r2], #1
    1376:	0709      	lsls	r1, r1, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    1378:	f043 0c01 	orr.w	ip, r3, #1
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    137c:	d505      	bpl.n	138a <usb_rx_memory+0x22>
			if (table[index(i, RX, EVEN)].desc == 0) {
    137e:	f854 1033 	ldr.w	r1, [r4, r3, lsl #3]
    1382:	b169      	cbz	r1, 13a0 <usb_rx_memory+0x38>
			if (table[index(i, RX, ODD)].desc == 0) {
    1384:	f854 103c 	ldr.w	r1, [r4, ip, lsl #3]
    1388:	b1c9      	cbz	r1, 13be <usb_rx_memory+0x56>
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    138a:	3304      	adds	r3, #4
    138c:	2b18      	cmp	r3, #24
    138e:	d1f0      	bne.n	1372 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    1390:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    1392:	4b13      	ldr	r3, [pc, #76]	; (13e0 <usb_rx_memory+0x78>)
    1394:	2200      	movs	r2, #0
    1396:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    1398:	f85d 4b04 	ldr.w	r4, [sp], #4
	usb_free(packet);
    139c:	f000 bd2c 	b.w	1df8 <usb_free>
				usb_rx_memory_needed--;
    13a0:	490f      	ldr	r1, [pc, #60]	; (13e0 <usb_rx_memory+0x78>)
				table[index(i, RX, EVEN)].addr = packet->buf;
    13a2:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    13a6:	3008      	adds	r0, #8
    13a8:	6050      	str	r0, [r2, #4]
				usb_rx_memory_needed--;
    13aa:	780a      	ldrb	r2, [r1, #0]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    13ac:	480d      	ldr	r0, [pc, #52]	; (13e4 <usb_rx_memory+0x7c>)
    13ae:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
				usb_rx_memory_needed--;
    13b2:	3a01      	subs	r2, #1
    13b4:	700a      	strb	r2, [r1, #0]
				__enable_irq();
    13b6:	b662      	cpsie	i
}
    13b8:	f85d 4b04 	ldr.w	r4, [sp], #4
    13bc:	4770      	bx	lr
				usb_rx_memory_needed--;
    13be:	4a08      	ldr	r2, [pc, #32]	; (13e0 <usb_rx_memory+0x78>)
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    13c0:	4909      	ldr	r1, [pc, #36]	; (13e8 <usb_rx_memory+0x80>)
				table[index(i, RX, ODD)].addr = packet->buf;
    13c2:	eb04 03cc 	add.w	r3, r4, ip, lsl #3
    13c6:	3008      	adds	r0, #8
    13c8:	6058      	str	r0, [r3, #4]
				usb_rx_memory_needed--;
    13ca:	7813      	ldrb	r3, [r2, #0]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    13cc:	f844 103c 	str.w	r1, [r4, ip, lsl #3]
				usb_rx_memory_needed--;
    13d0:	3b01      	subs	r3, #1
    13d2:	7013      	strb	r3, [r2, #0]
				__enable_irq();
    13d4:	b662      	cpsie	i
				return;
    13d6:	e7ef      	b.n	13b8 <usb_rx_memory+0x50>
    13d8:	00002864 	.word	0x00002864
    13dc:	1fff0000 	.word	0x1fff0000
    13e0:	1fff0cee 	.word	0x1fff0cee
    13e4:	00400088 	.word	0x00400088
    13e8:	004000c8 	.word	0x004000c8

000013ec <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    13ec:	1e42      	subs	r2, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    13ee:	2a04      	cmp	r2, #4
    13f0:	d80e      	bhi.n	1410 <usb_tx+0x24>
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    13f2:	4b1c      	ldr	r3, [pc, #112]	; (1464 <usb_tx+0x78>)
    13f4:	0140      	lsls	r0, r0, #5
    13f6:	f040 0010 	orr.w	r0, r0, #16
{
    13fa:	b410      	push	{r4}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    13fc:	4403      	add	r3, r0
	__disable_irq();
    13fe:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    1400:	4c19      	ldr	r4, [pc, #100]	; (1468 <usb_tx+0x7c>)
    1402:	5ca0      	ldrb	r0, [r4, r2]
    1404:	2803      	cmp	r0, #3
    1406:	d81d      	bhi.n	1444 <usb_tx+0x58>
    1408:	e8df f000 	tbb	[pc, r0]
    140c:	19031614 	.word	0x19031614
    1410:	4770      	bx	lr
    1412:	2005      	movs	r0, #5
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    1414:	54a0      	strb	r0, [r4, r2]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    1416:	f013 0f08 	tst.w	r3, #8
    141a:	8808      	ldrh	r0, [r1, #0]
    141c:	bf14      	ite	ne
    141e:	22c8      	movne	r2, #200	; 0xc8
    1420:	2288      	moveq	r2, #136	; 0x88
	b->addr = packet->buf;
    1422:	3108      	adds	r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    1424:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
	b->addr = packet->buf;
    1428:	6059      	str	r1, [r3, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    142a:	601a      	str	r2, [r3, #0]
	__enable_irq();
    142c:	b662      	cpsie	i
}
    142e:	f85d 4b04 	ldr.w	r4, [sp], #4
    1432:	4770      	bx	lr
		next = TX_STATE_ODD_FREE;
    1434:	2003      	movs	r0, #3
    1436:	e7ed      	b.n	1414 <usb_tx+0x28>
		b++;
    1438:	3308      	adds	r3, #8
		next = TX_STATE_EVEN_FREE;
    143a:	2002      	movs	r0, #2
		break;
    143c:	e7ea      	b.n	1414 <usb_tx+0x28>
		b++;
    143e:	3308      	adds	r3, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    1440:	2004      	movs	r0, #4
		break;
    1442:	e7e7      	b.n	1414 <usb_tx+0x28>
		if (tx_first[endpoint] == NULL) {
    1444:	4b09      	ldr	r3, [pc, #36]	; (146c <usb_tx+0x80>)
    1446:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    144a:	b138      	cbz	r0, 145c <usb_tx+0x70>
			tx_last[endpoint]->next = packet;
    144c:	4b08      	ldr	r3, [pc, #32]	; (1470 <usb_tx+0x84>)
    144e:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    1452:	6041      	str	r1, [r0, #4]
		tx_last[endpoint] = packet;
    1454:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		__enable_irq();
    1458:	b662      	cpsie	i
		return;
    145a:	e7e8      	b.n	142e <usb_tx+0x42>
			tx_first[endpoint] = packet;
    145c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    1460:	4b03      	ldr	r3, [pc, #12]	; (1470 <usb_tx+0x84>)
    1462:	e7f7      	b.n	1454 <usb_tx+0x68>
    1464:	1fff0000 	.word	0x1fff0000
    1468:	1fff0cdc 	.word	0x1fff0cdc
    146c:	1fff0cb4 	.word	0x1fff0cb4
    1470:	1fff0cc8 	.word	0x1fff0cc8

00001474 <usb_isr>:
}



void usb_isr(void)
{
    1474:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    1478:	f8df 9320 	ldr.w	r9, [pc, #800]	; 179c <usb_isr+0x328>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    147c:	f8df a320 	ldr.w	sl, [pc, #800]	; 17a0 <usb_isr+0x32c>
    1480:	f8df b320 	ldr.w	fp, [pc, #800]	; 17a4 <usb_isr+0x330>
{
    1484:	b087      	sub	sp, #28
    1486:	e03d      	b.n	1504 <usb_isr+0x90>
			bdt_t *b = stat2bufferdescriptor(stat);
    1488:	4db4      	ldr	r5, [pc, #720]	; (175c <usb_isr+0x2e8>)
    148a:	089e      	lsrs	r6, r3, #2
    148c:	eb05 07c6 	add.w	r7, r5, r6, lsl #3
			endpoint--;	// endpoint is index to zero-based arrays
    1490:	3a01      	subs	r2, #1
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    1492:	6879      	ldr	r1, [r7, #4]
			if (stat & 0x08) { // transmit
    1494:	f013 0308 	ands.w	r3, r3, #8
			endpoint--;	// endpoint is index to zero-based arrays
    1498:	b2d4      	uxtb	r4, r2
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    149a:	f1a1 0008 	sub.w	r0, r1, #8
			if (stat & 0x08) { // transmit
    149e:	f040 80c0 	bne.w	1622 <usb_isr+0x1ae>
				packet->len = b->desc >> 16;
    14a2:	f855 2036 	ldr.w	r2, [r5, r6, lsl #3]
    14a6:	ea4f 4c12 	mov.w	ip, r2, lsr #16
				if (packet->len > 0) {
    14aa:	0c12      	lsrs	r2, r2, #16
				packet->len = b->desc >> 16;
    14ac:	f821 cc08 	strh.w	ip, [r1, #-8]
				if (packet->len > 0) {
    14b0:	f000 80af 	beq.w	1612 <usb_isr+0x19e>
					packet->index = 0;
    14b4:	f821 3c06 	strh.w	r3, [r1, #-6]
					packet->next = NULL;
    14b8:	f841 3c04 	str.w	r3, [r1, #-4]
					if (rx_first[endpoint] == NULL) {
    14bc:	4ba8      	ldr	r3, [pc, #672]	; (1760 <usb_isr+0x2ec>)
    14be:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
    14c2:	2a00      	cmp	r2, #0
    14c4:	f000 81b3 	beq.w	182e <usb_isr+0x3ba>
						rx_last[endpoint]->next = packet;
    14c8:	4ba6      	ldr	r3, [pc, #664]	; (1764 <usb_isr+0x2f0>)
    14ca:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
    14ce:	6050      	str	r0, [r2, #4]
					rx_last[endpoint] = packet;
    14d0:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    14d4:	4ba4      	ldr	r3, [pc, #656]	; (1768 <usb_isr+0x2f4>)
    14d6:	f833 2014 	ldrh.w	r2, [r3, r4, lsl #1]
    14da:	4494      	add	ip, r2
    14dc:	f823 c014 	strh.w	ip, [r3, r4, lsl #1]
					packet = usb_malloc();
    14e0:	f000 fc6a 	bl	1db8 <usb_malloc>
					if (packet) {
    14e4:	2800      	cmp	r0, #0
    14e6:	f000 819b 	beq.w	1820 <usb_isr+0x3ac>
						b->desc = BDT_DESC(64,
    14ea:	f017 0f08 	tst.w	r7, #8
						b->addr = packet->buf;
    14ee:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    14f2:	bf14      	ite	ne
    14f4:	4653      	movne	r3, sl
    14f6:	465b      	moveq	r3, fp
						b->addr = packet->buf;
    14f8:	6078      	str	r0, [r7, #4]
						b->desc = BDT_DESC(64,
    14fa:	f845 3036 	str.w	r3, [r5, r6, lsl #3]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    14fe:	2308      	movs	r3, #8
    1500:	f889 3080 	strb.w	r3, [r9, #128]	; 0x80
	status = USB0_ISTAT;
    1504:	f899 3080 	ldrb.w	r3, [r9, #128]	; 0x80
	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    1508:	0759      	lsls	r1, r3, #29
	status = USB0_ISTAT;
    150a:	b2dc      	uxtb	r4, r3
	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    150c:	d51d      	bpl.n	154a <usb_isr+0xd6>
		if (usb_configuration) {
    150e:	4b97      	ldr	r3, [pc, #604]	; (176c <usb_isr+0x2f8>)
    1510:	781b      	ldrb	r3, [r3, #0]
    1512:	b1bb      	cbz	r3, 1544 <usb_isr+0xd0>
			t = usb_reboot_timer;
    1514:	4996      	ldr	r1, [pc, #600]	; (1770 <usb_isr+0x2fc>)
    1516:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    1518:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    151c:	b12a      	cbz	r2, 152a <usb_isr+0xb6>
				usb_reboot_timer = --t;
    151e:	3b01      	subs	r3, #1
    1520:	b2db      	uxtb	r3, r3
    1522:	700b      	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    1524:	2b00      	cmp	r3, #0
    1526:	f000 8358 	beq.w	1bda <usb_isr+0x766>
			t = usb_seremu_transmit_flush_timer;
    152a:	4992      	ldr	r1, [pc, #584]	; (1774 <usb_isr+0x300>)
    152c:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    152e:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    1532:	b12a      	cbz	r2, 1540 <usb_isr+0xcc>
				usb_seremu_transmit_flush_timer = --t;
    1534:	3b01      	subs	r3, #1
    1536:	b2db      	uxtb	r3, r3
    1538:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_seremu_flush_callback();
    153a:	2b00      	cmp	r3, #0
    153c:	f000 819d 	beq.w	187a <usb_isr+0x406>
			usb_flightsim_flush_callback();
    1540:	f000 fbbe 	bl	1cc0 <usb_flightsim_flush_callback>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    1544:	2304      	movs	r3, #4
    1546:	f889 3080 	strb.w	r3, [r9, #128]	; 0x80
	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    154a:	f014 0208 	ands.w	r2, r4, #8
    154e:	f000 817c 	beq.w	184a <usb_isr+0x3d6>
		stat = USB0_STAT;
    1552:	f899 2090 	ldrb.w	r2, [r9, #144]	; 0x90
    1556:	b2d3      	uxtb	r3, r2
		if (endpoint == 0) {
    1558:	0912      	lsrs	r2, r2, #4
    155a:	d195      	bne.n	1488 <usb_isr+0x14>
	b = stat2bufferdescriptor(stat);
    155c:	f8df 81fc 	ldr.w	r8, [pc, #508]	; 175c <usb_isr+0x2e8>
    1560:	089b      	lsrs	r3, r3, #2
    1562:	eb08 04c3 	add.w	r4, r8, r3, lsl #3
	pid = BDT_PID(b->desc);
    1566:	f858 0033 	ldr.w	r0, [r8, r3, lsl #3]
	buf = b->addr;
    156a:	6865      	ldr	r5, [r4, #4]
	pid = BDT_PID(b->desc);
    156c:	f3c0 0083 	ubfx	r0, r0, #2, #4
	switch (pid) {
    1570:	2809      	cmp	r0, #9
    1572:	f000 8082 	beq.w	167a <usb_isr+0x206>
    1576:	d814      	bhi.n	15a2 <usb_isr+0x12e>
    1578:	3801      	subs	r0, #1
    157a:	2801      	cmp	r0, #1
    157c:	d80d      	bhi.n	159a <usb_isr+0x126>
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    157e:	487e      	ldr	r0, [pc, #504]	; (1778 <usb_isr+0x304>)
    1580:	8806      	ldrh	r6, [r0, #0]
    1582:	f242 0421 	movw	r4, #8225	; 0x2021
    1586:	42a6      	cmp	r6, r4
    1588:	f000 81f4 	beq.w	1974 <usb_isr+0x500>
		if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    158c:	4a7b      	ldr	r2, [pc, #492]	; (177c <usb_isr+0x308>)
    158e:	6804      	ldr	r4, [r0, #0]
    1590:	4294      	cmp	r4, r2
    1592:	f000 81a6 	beq.w	18e2 <usb_isr+0x46e>
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    1596:	f848 a033 	str.w	sl, [r8, r3, lsl #3]
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    159a:	2301      	movs	r3, #1
    159c:	f889 3094 	strb.w	r3, [r9, #148]	; 0x94
}
    15a0:	e7ad      	b.n	14fe <usb_isr+0x8a>
	switch (pid) {
    15a2:	280d      	cmp	r0, #13
    15a4:	d1f9      	bne.n	159a <usb_isr+0x126>
		setup.word2 = *(uint32_t *)(buf + 4);
    15a6:	e9d5 6700 	ldrd	r6, r7, [r5]
		ep0_tx_ptr = NULL;
    15aa:	4d75      	ldr	r5, [pc, #468]	; (1780 <usb_isr+0x30c>)
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    15ac:	f848 a033 	str.w	sl, [r8, r3, lsl #3]
		setup.word1 = *(uint32_t *)(buf);
    15b0:	4871      	ldr	r0, [pc, #452]	; (1778 <usb_isr+0x304>)
		ep0_tx_data_toggle = 1;
    15b2:	4c74      	ldr	r4, [pc, #464]	; (1784 <usb_isr+0x310>)
		table[index(0, TX, EVEN)].desc = 0;
    15b4:	f8c8 2010 	str.w	r2, [r8, #16]
    15b8:	b2b3      	uxth	r3, r6
	switch (setup.wRequestAndType) {
    15ba:	f240 6c81 	movw	ip, #1665	; 0x681
		table[index(0, TX, ODD)].desc = 0;
    15be:	f8c8 2018 	str.w	r2, [r8, #24]
		ep0_tx_ptr = NULL;
    15c2:	602a      	str	r2, [r5, #0]
	switch (setup.wRequestAndType) {
    15c4:	4563      	cmp	r3, ip
		ep0_tx_data_toggle = 1;
    15c6:	f04f 0201 	mov.w	r2, #1
		setup.word2 = *(uint32_t *)(buf + 4);
    15ca:	e9c0 6700 	strd	r6, r7, [r0]
		ep0_tx_data_toggle = 1;
    15ce:	7022      	strb	r2, [r4, #0]
	switch (setup.wRequestAndType) {
    15d0:	f200 8100 	bhi.w	17d4 <usb_isr+0x360>
    15d4:	f5b3 6fd0 	cmp.w	r3, #1664	; 0x680
    15d8:	f080 81e5 	bcs.w	19a6 <usb_isr+0x532>
    15dc:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    15e0:	f000 8202 	beq.w	19e8 <usb_isr+0x574>
    15e4:	f240 80e0 	bls.w	17a8 <usb_isr+0x334>
    15e8:	f240 3202 	movw	r2, #770	; 0x302
    15ec:	4293      	cmp	r3, r2
    15ee:	d17d      	bne.n	16ec <usb_isr+0x278>
		i = setup.wIndex & 0x7F;
    15f0:	f007 077f 	and.w	r7, r7, #127	; 0x7f
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    15f4:	2f05      	cmp	r7, #5
    15f6:	f200 80f9 	bhi.w	17ec <usb_isr+0x378>
    15fa:	0c32      	lsrs	r2, r6, #16
    15fc:	f040 80f6 	bne.w	17ec <usb_isr+0x378>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    1600:	4961      	ldr	r1, [pc, #388]	; (1788 <usb_isr+0x314>)
    1602:	f811 3027 	ldrb.w	r3, [r1, r7, lsl #2]
    1606:	f043 0302 	orr.w	r3, r3, #2
    160a:	f801 3027 	strb.w	r3, [r1, r7, lsl #2]
	const uint8_t *data = NULL;
    160e:	4613      	mov	r3, r2
		break;
    1610:	e071      	b.n	16f6 <usb_isr+0x282>
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    1612:	f017 0f08 	tst.w	r7, #8
    1616:	bf14      	ite	ne
    1618:	4653      	movne	r3, sl
    161a:	465b      	moveq	r3, fp
    161c:	f845 3036 	str.w	r3, [r5, r6, lsl #3]
    1620:	e76d      	b.n	14fe <usb_isr+0x8a>
				usb_free(packet);
    1622:	f000 fbe9 	bl	1df8 <usb_free>
				packet = tx_first[endpoint];
    1626:	4a59      	ldr	r2, [pc, #356]	; (178c <usb_isr+0x318>)
					switch (tx_state[endpoint]) {
    1628:	4859      	ldr	r0, [pc, #356]	; (1790 <usb_isr+0x31c>)
				packet = tx_first[endpoint];
    162a:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
				if (packet) {
    162e:	2b00      	cmp	r3, #0
    1630:	f000 8101 	beq.w	1836 <usb_isr+0x3c2>
					tx_first[endpoint] = packet->next;
    1634:	6859      	ldr	r1, [r3, #4]
    1636:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
					switch (tx_state[endpoint]) {
    163a:	5d02      	ldrb	r2, [r0, r4]
					b->addr = packet->buf;
    163c:	f103 0108 	add.w	r1, r3, #8
    1640:	6079      	str	r1, [r7, #4]
					switch (tx_state[endpoint]) {
    1642:	2a03      	cmp	r2, #3
    1644:	d805      	bhi.n	1652 <usb_isr+0x1de>
    1646:	e8df f002 	tbb	[pc, r2]
    164a:	0f12      	.short	0x0f12
    164c:	0215      	.short	0x0215
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    164e:	2204      	movs	r2, #4
    1650:	5502      	strb	r2, [r0, r4]
					b->desc = BDT_DESC(packet->len,
    1652:	881a      	ldrh	r2, [r3, #0]
    1654:	f017 0f08 	tst.w	r7, #8
    1658:	bf14      	ite	ne
    165a:	23c8      	movne	r3, #200	; 0xc8
    165c:	2388      	moveq	r3, #136	; 0x88
    165e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    1662:	f845 3036 	str.w	r3, [r5, r6, lsl #3]
    1666:	e74a      	b.n	14fe <usb_isr+0x8a>
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    1668:	2202      	movs	r2, #2
    166a:	5502      	strb	r2, [r0, r4]
						break;
    166c:	e7f1      	b.n	1652 <usb_isr+0x1de>
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    166e:	2203      	movs	r2, #3
    1670:	5502      	strb	r2, [r0, r4]
						break;
    1672:	e7ee      	b.n	1652 <usb_isr+0x1de>
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    1674:	2205      	movs	r2, #5
    1676:	5502      	strb	r2, [r0, r4]
						break;
    1678:	e7eb      	b.n	1652 <usb_isr+0x1de>
		data = ep0_tx_ptr;
    167a:	4d41      	ldr	r5, [pc, #260]	; (1780 <usb_isr+0x30c>)
    167c:	682a      	ldr	r2, [r5, #0]
		if (data) {
    167e:	b34a      	cbz	r2, 16d4 <usb_isr+0x260>
			size = ep0_tx_len;
    1680:	4f44      	ldr	r7, [pc, #272]	; (1794 <usb_isr+0x320>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1682:	4c40      	ldr	r4, [pc, #256]	; (1784 <usb_isr+0x310>)
			size = ep0_tx_len;
    1684:	8838      	ldrh	r0, [r7, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1686:	4e44      	ldr	r6, [pc, #272]	; (1798 <usb_isr+0x324>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1688:	f894 e000 	ldrb.w	lr, [r4]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    168c:	f896 c000 	ldrb.w	ip, [r6]
    1690:	2840      	cmp	r0, #64	; 0x40
    1692:	4603      	mov	r3, r0
    1694:	bf28      	it	cs
    1696:	2340      	movcs	r3, #64	; 0x40
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1698:	f1be 0f00 	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
    169c:	f08e 0e01 	eor.w	lr, lr, #1
    16a0:	f884 e000 	strb.w	lr, [r4]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    16a4:	f04c 0402 	orr.w	r4, ip, #2
	ep0_tx_bdt_bank ^= 1;
    16a8:	f08c 0c01 	eor.w	ip, ip, #1
    16ac:	f886 c000 	strb.w	ip, [r6]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    16b0:	eb08 06c4 	add.w	r6, r8, r4, lsl #3
    16b4:	6072      	str	r2, [r6, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    16b6:	bf14      	ite	ne
    16b8:	26c8      	movne	r6, #200	; 0xc8
    16ba:	2688      	moveq	r6, #136	; 0x88
    16bc:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
			data += size;
    16c0:	441a      	add	r2, r3
			ep0_tx_len -= size;
    16c2:	1ac3      	subs	r3, r0, r3
    16c4:	b29b      	uxth	r3, r3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    16c6:	f848 6034 	str.w	r6, [r8, r4, lsl #3]
			ep0_tx_len -= size;
    16ca:	803b      	strh	r3, [r7, #0]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    16cc:	2b00      	cmp	r3, #0
    16ce:	f000 80de 	beq.w	188e <usb_isr+0x41a>
    16d2:	602a      	str	r2, [r5, #0]
		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    16d4:	4b28      	ldr	r3, [pc, #160]	; (1778 <usb_isr+0x304>)
    16d6:	881a      	ldrh	r2, [r3, #0]
    16d8:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    16dc:	f47f af5d 	bne.w	159a <usb_isr+0x126>
			USB0_ADDR = setup.wValue;
    16e0:	789a      	ldrb	r2, [r3, #2]
    16e2:	f889 2098 	strb.w	r2, [r9, #152]	; 0x98
			setup.bRequest = 0;
    16e6:	2200      	movs	r2, #0
    16e8:	705a      	strb	r2, [r3, #1]
			USB0_ADDR = setup.wValue;
    16ea:	e756      	b.n	159a <usb_isr+0x126>
	switch (setup.wRequestAndType) {
    16ec:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    16f0:	d17c      	bne.n	17ec <usb_isr+0x378>
    16f2:	2200      	movs	r2, #0
    16f4:	4613      	mov	r3, r2
	if (datalen > setup.wLength) datalen = setup.wLength;
    16f6:	f8b0 c006 	ldrh.w	ip, [r0, #6]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    16fa:	4e27      	ldr	r6, [pc, #156]	; (1798 <usb_isr+0x324>)
    16fc:	4594      	cmp	ip, r2
    16fe:	bf28      	it	cs
    1700:	4694      	movcs	ip, r2
	if (size > EP0_SIZE) size = EP0_SIZE;
    1702:	4660      	mov	r0, ip
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1704:	7832      	ldrb	r2, [r6, #0]
    1706:	2840      	cmp	r0, #64	; 0x40
    1708:	bf28      	it	cs
    170a:	2040      	movcs	r0, #64	; 0x40
    170c:	f042 0e02 	orr.w	lr, r2, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1710:	0407      	lsls	r7, r0, #16
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1712:	eb08 01ce 	add.w	r1, r8, lr, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1716:	f047 07c8 	orr.w	r7, r7, #200	; 0xc8
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    171a:	604b      	str	r3, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    171c:	f848 703e 	str.w	r7, [r8, lr, lsl #3]
	ep0_tx_data_toggle ^= 1;
    1720:	2700      	movs	r7, #0
	data += size;
    1722:	4403      	add	r3, r0
	ep0_tx_data_toggle ^= 1;
    1724:	7027      	strb	r7, [r4, #0]
	if (datalen == 0 && size < EP0_SIZE) return;
    1726:	ebbc 0000 	subs.w	r0, ip, r0
	ep0_tx_bdt_bank ^= 1;
    172a:	f082 0701 	eor.w	r7, r2, #1
    172e:	7037      	strb	r7, [r6, #0]
	if (datalen == 0 && size < EP0_SIZE) return;
    1730:	f040 80bb 	bne.w	18aa <usb_isr+0x436>
    1734:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
    1738:	f04f 0001 	mov.w	r0, #1
    173c:	d909      	bls.n	1752 <usb_isr+0x2de>
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    173e:	f047 0702 	orr.w	r7, r7, #2
	ep0_tx_bdt_bank ^= 1;
    1742:	7032      	strb	r2, [r6, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1744:	eb08 02c7 	add.w	r2, r8, r7, lsl #3
	ep0_tx_data_toggle ^= 1;
    1748:	7020      	strb	r0, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    174a:	6053      	str	r3, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    174c:	2388      	movs	r3, #136	; 0x88
    174e:	f848 3037 	str.w	r3, [r8, r7, lsl #3]
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    1752:	2301      	movs	r3, #1
    1754:	f889 3094 	strb.w	r3, [r9, #148]	; 0x94
		break;
    1758:	e71f      	b.n	159a <usb_isr+0x126>
    175a:	bf00      	nop
    175c:	1fff0000 	.word	0x1fff0000
    1760:	1fff0c84 	.word	0x1fff0c84
    1764:	1fff0c98 	.word	0x1fff0c98
    1768:	1fff0ce4 	.word	0x1fff0ce4
    176c:	1fff0ce1 	.word	0x1fff0ce1
    1770:	1fff0ce2 	.word	0x1fff0ce2
    1774:	1fff0d15 	.word	0x1fff0d15
    1778:	1fff0cac 	.word	0x1fff0cac
    177c:	03000921 	.word	0x03000921
    1780:	1fff0c78 	.word	0x1fff0c78
    1784:	1fff0c75 	.word	0x1fff0c75
    1788:	400720c0 	.word	0x400720c0
    178c:	1fff0cb4 	.word	0x1fff0cb4
    1790:	1fff0cdc 	.word	0x1fff0cdc
    1794:	1fff0c76 	.word	0x1fff0c76
    1798:	1fff0c74 	.word	0x1fff0c74
    179c:	40072000 	.word	0x40072000
    17a0:	004000c8 	.word	0x004000c8
    17a4:	00400088 	.word	0x00400088
	switch (setup.wRequestAndType) {
    17a8:	2b80      	cmp	r3, #128	; 0x80
    17aa:	f000 81ed 	beq.w	1b88 <usb_isr+0x714>
    17ae:	2b82      	cmp	r3, #130	; 0x82
    17b0:	d11c      	bne.n	17ec <usb_isr+0x378>
		i = setup.wIndex & 0x7F;
    17b2:	f007 027f 	and.w	r2, r7, #127	; 0x7f
		if (i > NUM_ENDPOINTS) {
    17b6:	2a05      	cmp	r2, #5
    17b8:	d818      	bhi.n	17ec <usb_isr+0x378>
		reply_buffer[0] = 0;
    17ba:	4b97      	ldr	r3, [pc, #604]	; (1a18 <usb_isr+0x5a4>)
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    17bc:	4997      	ldr	r1, [pc, #604]	; (1a1c <usb_isr+0x5a8>)
		reply_buffer[0] = 0;
    17be:	2600      	movs	r6, #0
    17c0:	801e      	strh	r6, [r3, #0]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    17c2:	f811 2022 	ldrb.w	r2, [r1, r2, lsl #2]
    17c6:	0796      	lsls	r6, r2, #30
    17c8:	f140 8205 	bpl.w	1bd6 <usb_isr+0x762>
    17cc:	2201      	movs	r2, #1
    17ce:	701a      	strb	r2, [r3, #0]
		datalen = 2;
    17d0:	2202      	movs	r2, #2
    17d2:	e790      	b.n	16f6 <usb_isr+0x282>
	switch (setup.wRequestAndType) {
    17d4:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    17d8:	f000 8118 	beq.w	1a0c <usb_isr+0x598>
    17dc:	d90d      	bls.n	17fa <usb_isr+0x386>
    17de:	f640 1221 	movw	r2, #2337	; 0x921
    17e2:	4293      	cmp	r3, r2
    17e4:	d0b5      	beq.n	1752 <usb_isr+0x2de>
    17e6:	f5b3 6f12 	cmp.w	r3, #2336	; 0x920
    17ea:	d80e      	bhi.n	180a <usb_isr+0x396>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    17ec:	230f      	movs	r3, #15
    17ee:	f889 30c0 	strb.w	r3, [r9, #192]	; 0xc0
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    17f2:	2301      	movs	r3, #1
    17f4:	f889 3094 	strb.w	r3, [r9, #148]	; 0x94
		break;
    17f8:	e6cf      	b.n	159a <usb_isr+0x126>
	switch (setup.wRequestAndType) {
    17fa:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    17fe:	d1f5      	bne.n	17ec <usb_isr+0x378>
		reply_buffer[0] = usb_configuration;
    1800:	4b87      	ldr	r3, [pc, #540]	; (1a20 <usb_isr+0x5ac>)
    1802:	781e      	ldrb	r6, [r3, #0]
    1804:	4b84      	ldr	r3, [pc, #528]	; (1a18 <usb_isr+0x5a4>)
    1806:	701e      	strb	r6, [r3, #0]
		break;
    1808:	e775      	b.n	16f6 <usb_isr+0x282>
	switch (setup.wRequestAndType) {
    180a:	f640 2221 	movw	r2, #2593	; 0xa21
    180e:	4293      	cmp	r3, r2
    1810:	f43f af6f 	beq.w	16f2 <usb_isr+0x27e>
    1814:	f242 2221 	movw	r2, #8737	; 0x2221
    1818:	4293      	cmp	r3, r2
    181a:	f43f af6a 	beq.w	16f2 <usb_isr+0x27e>
    181e:	e7e5      	b.n	17ec <usb_isr+0x378>
						usb_rx_memory_needed++;
    1820:	4a80      	ldr	r2, [pc, #512]	; (1a24 <usb_isr+0x5b0>)
						b->desc = 0;
    1822:	f845 0036 	str.w	r0, [r5, r6, lsl #3]
						usb_rx_memory_needed++;
    1826:	7813      	ldrb	r3, [r2, #0]
    1828:	3301      	adds	r3, #1
    182a:	7013      	strb	r3, [r2, #0]
    182c:	e667      	b.n	14fe <usb_isr+0x8a>
						rx_first[endpoint] = packet;
    182e:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
    1832:	4b7d      	ldr	r3, [pc, #500]	; (1a28 <usb_isr+0x5b4>)
    1834:	e64c      	b.n	14d0 <usb_isr+0x5c>
					switch (tx_state[endpoint]) {
    1836:	5d02      	ldrb	r2, [r0, r4]
    1838:	2a02      	cmp	r2, #2
    183a:	d026      	beq.n	188a <usb_isr+0x416>
    183c:	f67f ae5f 	bls.w	14fe <usb_isr+0x8a>
    1840:	2a03      	cmp	r2, #3
    1842:	d11d      	bne.n	1880 <usb_isr+0x40c>
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1844:	2301      	movs	r3, #1
    1846:	5503      	strb	r3, [r0, r4]
						break;
    1848:	e659      	b.n	14fe <usb_isr+0x8a>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    184a:	07e0      	lsls	r0, r4, #31
    184c:	d46d      	bmi.n	192a <usb_isr+0x4b6>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    184e:	0621      	lsls	r1, r4, #24
    1850:	d421      	bmi.n	1896 <usb_isr+0x422>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    1852:	07a2      	lsls	r2, r4, #30
    1854:	d508      	bpl.n	1868 <usb_isr+0x3f4>
		uint8_t err = USB0_ERRSTAT;
    1856:	4b75      	ldr	r3, [pc, #468]	; (1a2c <usb_isr+0x5b8>)
    1858:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    185c:	2102      	movs	r1, #2
		uint8_t err = USB0_ERRSTAT;
    185e:	b2d2      	uxtb	r2, r2
		USB0_ERRSTAT = err;
    1860:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
		USB0_ISTAT = USB_ISTAT_ERROR;
    1864:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    1868:	06e3      	lsls	r3, r4, #27
    186a:	d503      	bpl.n	1874 <usb_isr+0x400>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    186c:	4b6f      	ldr	r3, [pc, #444]	; (1a2c <usb_isr+0x5b8>)
    186e:	2210      	movs	r2, #16
    1870:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	}

}
    1874:	b007      	add	sp, #28
    1876:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (t == 0) usb_seremu_flush_callback();
    187a:	f000 fc3d 	bl	20f8 <usb_seremu_flush_callback>
    187e:	e65f      	b.n	1540 <usb_isr+0xcc>
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    1880:	f017 0f08 	tst.w	r7, #8
    1884:	bf14      	ite	ne
    1886:	2303      	movne	r3, #3
    1888:	2302      	moveq	r3, #2
    188a:	5503      	strb	r3, [r0, r4]
						break;
    188c:	e637      	b.n	14fe <usb_isr+0x8a>
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    188e:	283f      	cmp	r0, #63	; 0x3f
    1890:	bf98      	it	ls
    1892:	2200      	movls	r2, #0
    1894:	e71d      	b.n	16d2 <usb_isr+0x25e>
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1896:	4b65      	ldr	r3, [pc, #404]	; (1a2c <usb_isr+0x5b8>)
		USB0_ISTAT = USB_ISTAT_STALL;
    1898:	2280      	movs	r2, #128	; 0x80
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    189a:	210d      	movs	r1, #13
    189c:	f883 10c0 	strb.w	r1, [r3, #192]	; 0xc0
		USB0_ISTAT = USB_ISTAT_STALL;
    18a0:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    18a4:	07a2      	lsls	r2, r4, #30
    18a6:	d5df      	bpl.n	1868 <usb_isr+0x3f4>
    18a8:	e7d5      	b.n	1856 <usb_isr+0x3e2>
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    18aa:	f047 0702 	orr.w	r7, r7, #2
	ep0_tx_bdt_bank ^= 1;
    18ae:	7032      	strb	r2, [r6, #0]
    18b0:	2840      	cmp	r0, #64	; 0x40
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    18b2:	eb08 06c7 	add.w	r6, r8, r7, lsl #3
    18b6:	4602      	mov	r2, r0
    18b8:	bf28      	it	cs
    18ba:	2240      	movcs	r2, #64	; 0x40
    18bc:	6073      	str	r3, [r6, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    18be:	0416      	lsls	r6, r2, #16
	data += size;
    18c0:	4413      	add	r3, r2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    18c2:	f046 0688 	orr.w	r6, r6, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    18c6:	2101      	movs	r1, #1
	if (datalen == 0 && size < EP0_SIZE) return;
    18c8:	1a82      	subs	r2, r0, r2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    18ca:	f848 6037 	str.w	r6, [r8, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
    18ce:	7021      	strb	r1, [r4, #0]
	if (datalen == 0 && size < EP0_SIZE) return;
    18d0:	f000 815f 	beq.w	1b92 <usb_isr+0x71e>
	ep0_tx_ptr = data;
    18d4:	602b      	str	r3, [r5, #0]
	ep0_tx_len = datalen;
    18d6:	4b56      	ldr	r3, [pc, #344]	; (1a30 <usb_isr+0x5bc>)
    18d8:	801a      	strh	r2, [r3, #0]
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    18da:	2301      	movs	r3, #1
    18dc:	f889 3094 	strb.w	r3, [r9, #148]	; 0x94
		break;
    18e0:	e65b      	b.n	159a <usb_isr+0x126>
		if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    18e2:	6840      	ldr	r0, [r0, #4]
    18e4:	4a53      	ldr	r2, [pc, #332]	; (1a34 <usb_isr+0x5c0>)
    18e6:	4290      	cmp	r0, r2
    18e8:	f47f ae55 	bne.w	1596 <usb_isr+0x122>
			if (buf[0] == 0xA9 && buf[1] == 0x45 && buf[2] == 0xC2 && buf[3] == 0x6B) {
    18ec:	782a      	ldrb	r2, [r5, #0]
    18ee:	2aa9      	cmp	r2, #169	; 0xa9
    18f0:	f000 8161 	beq.w	1bb6 <usb_isr+0x742>
				usb_seremu_online = 1;
    18f4:	4a50      	ldr	r2, [pc, #320]	; (1a38 <usb_isr+0x5c4>)
    18f6:	2001      	movs	r0, #1
    18f8:	7010      	strb	r0, [r2, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    18fa:	4c50      	ldr	r4, [pc, #320]	; (1a3c <usb_isr+0x5c8>)
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    18fc:	4e50      	ldr	r6, [pc, #320]	; (1a40 <usb_isr+0x5cc>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    18fe:	7820      	ldrb	r0, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1900:	7832      	ldrb	r2, [r6, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1902:	2800      	cmp	r0, #0
	ep0_tx_data_toggle ^= 1;
    1904:	f080 0001 	eor.w	r0, r0, #1
    1908:	7020      	strb	r0, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    190a:	f042 0002 	orr.w	r0, r2, #2
	ep0_tx_bdt_bank ^= 1;
    190e:	f082 0201 	eor.w	r2, r2, #1
    1912:	7032      	strb	r2, [r6, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1914:	eb08 02c0 	add.w	r2, r8, r0, lsl #3
    1918:	f04f 0400 	mov.w	r4, #0
    191c:	6054      	str	r4, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    191e:	bf14      	ite	ne
    1920:	22c8      	movne	r2, #200	; 0xc8
    1922:	2288      	moveq	r2, #136	; 0x88
    1924:	f848 2030 	str.w	r2, [r8, r0, lsl #3]
}
    1928:	e635      	b.n	1596 <usb_isr+0x122>
		USB0_CTL = USB_CTL_ODDRST;
    192a:	4b40      	ldr	r3, [pc, #256]	; (1a2c <usb_isr+0x5b8>)
		ep0_tx_bdt_bank = 0;
    192c:	4844      	ldr	r0, [pc, #272]	; (1a40 <usb_isr+0x5cc>)
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    192e:	4945      	ldr	r1, [pc, #276]	; (1a44 <usb_isr+0x5d0>)
    1930:	4c45      	ldr	r4, [pc, #276]	; (1a48 <usb_isr+0x5d4>)
		USB0_CTL = USB_CTL_ODDRST;
    1932:	2502      	movs	r5, #2
    1934:	f883 5094 	strb.w	r5, [r3, #148]	; 0x94
		ep0_tx_bdt_bank = 0;
    1938:	7002      	strb	r2, [r0, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    193a:	4844      	ldr	r0, [pc, #272]	; (1a4c <usb_isr+0x5d8>)
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    193c:	600c      	str	r4, [r1, #0]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    193e:	4d44      	ldr	r5, [pc, #272]	; (1a50 <usb_isr+0x5dc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    1940:	6048      	str	r0, [r1, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    1942:	608c      	str	r4, [r1, #8]
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1944:	240d      	movs	r4, #13
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    1946:	60cd      	str	r5, [r1, #12]
		USB0_ERRSTAT = 0xFF;
    1948:	20ff      	movs	r0, #255	; 0xff
		table[index(0, TX, EVEN)].desc = 0;
    194a:	610a      	str	r2, [r1, #16]
		table[index(0, TX, ODD)].desc = 0;
    194c:	618a      	str	r2, [r1, #24]
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    194e:	f883 40c0 	strb.w	r4, [r3, #192]	; 0xc0
		USB0_CTL = USB_CTL_USBENSOFEN;
    1952:	2101      	movs	r1, #1
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    1954:	249f      	movs	r4, #159	; 0x9f
		USB0_ERRSTAT = 0xFF;
    1956:	f883 0088 	strb.w	r0, [r3, #136]	; 0x88
		USB0_ISTAT = 0xFF;
    195a:	f883 0080 	strb.w	r0, [r3, #128]	; 0x80
		USB0_ADDR = 0;
    195e:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
		USB0_ERREN = 0xFF;
    1962:	f883 008c 	strb.w	r0, [r3, #140]	; 0x8c
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    1966:	f883 4084 	strb.w	r4, [r3, #132]	; 0x84
		USB0_CTL = USB_CTL_USBENSOFEN;
    196a:	f883 1094 	strb.w	r1, [r3, #148]	; 0x94
}
    196e:	b007      	add	sp, #28
    1970:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1974:	4c31      	ldr	r4, [pc, #196]	; (1a3c <usb_isr+0x5c8>)
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1976:	4e32      	ldr	r6, [pc, #200]	; (1a40 <usb_isr+0x5cc>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1978:	f894 c000 	ldrb.w	ip, [r4]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    197c:	7837      	ldrb	r7, [r6, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    197e:	f1bc 0f00 	cmp.w	ip, #0
	ep0_tx_data_toggle ^= 1;
    1982:	f08c 0c01 	eor.w	ip, ip, #1
    1986:	f884 c000 	strb.w	ip, [r4]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    198a:	f047 0402 	orr.w	r4, r7, #2
	ep0_tx_bdt_bank ^= 1;
    198e:	f087 0701 	eor.w	r7, r7, #1
    1992:	7037      	strb	r7, [r6, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1994:	eb08 06c4 	add.w	r6, r8, r4, lsl #3
    1998:	6072      	str	r2, [r6, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    199a:	bf14      	ite	ne
    199c:	22c8      	movne	r2, #200	; 0xc8
    199e:	2288      	moveq	r2, #136	; 0x88
    19a0:	f848 2034 	str.w	r2, [r8, r4, lsl #3]
}
    19a4:	e5f2      	b.n	158c <usb_isr+0x118>
			if (list->addr == NULL) break;
    19a6:	4a2b      	ldr	r2, [pc, #172]	; (1a54 <usb_isr+0x5e0>)
    19a8:	6853      	ldr	r3, [r2, #4]
    19aa:	2b00      	cmp	r3, #0
    19ac:	f43f af1e 	beq.w	17ec <usb_isr+0x378>
		for (list = usb_descriptor_list; 1; list++) {
    19b0:	4694      	mov	ip, r2
    19b2:	ea4f 4e16 	mov.w	lr, r6, lsr #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    19b6:	b2ba      	uxth	r2, r7
    19b8:	e006      	b.n	19c8 <usb_isr+0x554>
			if (list->addr == NULL) break;
    19ba:	f8dc 3010 	ldr.w	r3, [ip, #16]
		for (list = usb_descriptor_list; 1; list++) {
    19be:	f10c 0c0c 	add.w	ip, ip, #12
			if (list->addr == NULL) break;
    19c2:	2b00      	cmp	r3, #0
    19c4:	f43f af12 	beq.w	17ec <usb_isr+0x378>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    19c8:	f8bc 1000 	ldrh.w	r1, [ip]
    19cc:	4571      	cmp	r1, lr
    19ce:	d1f4      	bne.n	19ba <usb_isr+0x546>
    19d0:	f8bc 1002 	ldrh.w	r1, [ip, #2]
    19d4:	4291      	cmp	r1, r2
    19d6:	d1f0      	bne.n	19ba <usb_isr+0x546>
				if ((setup.wValue >> 8) == 3) {
    19d8:	ea4f 261e 	mov.w	r6, lr, lsr #8
    19dc:	2e03      	cmp	r6, #3
					datalen = *(list->addr);
    19de:	bf0c      	ite	eq
    19e0:	781a      	ldrbeq	r2, [r3, #0]
					datalen = list->length;
    19e2:	f8bc 2008 	ldrhne.w	r2, [ip, #8]
    19e6:	e686      	b.n	16f6 <usb_isr+0x282>
		i = setup.wIndex & 0x7F;
    19e8:	f007 027f 	and.w	r2, r7, #127	; 0x7f
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    19ec:	2a05      	cmp	r2, #5
    19ee:	f63f aefd 	bhi.w	17ec <usb_isr+0x378>
    19f2:	0c36      	lsrs	r6, r6, #16
    19f4:	f47f aefa 	bne.w	17ec <usb_isr+0x378>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    19f8:	4908      	ldr	r1, [pc, #32]	; (1a1c <usb_isr+0x5a8>)
    19fa:	f811 3022 	ldrb.w	r3, [r1, r2, lsl #2]
    19fe:	f023 0302 	bic.w	r3, r3, #2
    1a02:	f801 3022 	strb.w	r3, [r1, r2, lsl #2]
	uint32_t datalen = 0;
    1a06:	2200      	movs	r2, #0
	const uint8_t *data = NULL;
    1a08:	4613      	mov	r3, r2
		break;
    1a0a:	e674      	b.n	16f6 <usb_isr+0x282>
		usb_configuration = setup.wValue;
    1a0c:	4b04      	ldr	r3, [pc, #16]	; (1a20 <usb_isr+0x5ac>)
    1a0e:	f3c6 4607 	ubfx	r6, r6, #16, #8
    1a12:	701e      	strb	r6, [r3, #0]
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    1a14:	2504      	movs	r5, #4
    1a16:	e022      	b.n	1a5e <usb_isr+0x5ea>
    1a18:	1fff0c7c 	.word	0x1fff0c7c
    1a1c:	400720c0 	.word	0x400720c0
    1a20:	1fff0ce1 	.word	0x1fff0ce1
    1a24:	1fff0cee 	.word	0x1fff0cee
    1a28:	1fff0c98 	.word	0x1fff0c98
    1a2c:	40072000 	.word	0x40072000
    1a30:	1fff0c76 	.word	0x1fff0c76
    1a34:	00040001 	.word	0x00040001
    1a38:	1fff0d14 	.word	0x1fff0d14
    1a3c:	1fff0c75 	.word	0x1fff0c75
    1a40:	1fff0c74 	.word	0x1fff0c74
    1a44:	1fff0000 	.word	0x1fff0000
    1a48:	00400088 	.word	0x00400088
    1a4c:	1fff0bf4 	.word	0x1fff0bf4
    1a50:	1fff0c34 	.word	0x1fff0c34
    1a54:	000027c8 	.word	0x000027c8
    1a58:	3501      	adds	r5, #1
    1a5a:	2d18      	cmp	r5, #24
    1a5c:	d00c      	beq.n	1a78 <usb_isr+0x604>
			if (table[i].desc & BDT_OWN) {
    1a5e:	f858 3035 	ldr.w	r3, [r8, r5, lsl #3]
    1a62:	061a      	lsls	r2, r3, #24
    1a64:	d5f8      	bpl.n	1a58 <usb_isr+0x5e4>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    1a66:	eb08 03c5 	add.w	r3, r8, r5, lsl #3
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    1a6a:	3501      	adds	r5, #1
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    1a6c:	6858      	ldr	r0, [r3, #4]
    1a6e:	3808      	subs	r0, #8
    1a70:	f000 f9c2 	bl	1df8 <usb_free>
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    1a74:	2d18      	cmp	r5, #24
    1a76:	d1f2      	bne.n	1a5e <usb_isr+0x5ea>
    1a78:	4a5c      	ldr	r2, [pc, #368]	; (1bec <usb_isr+0x778>)
    1a7a:	9201      	str	r2, [sp, #4]
    1a7c:	4a5c      	ldr	r2, [pc, #368]	; (1bf0 <usb_isr+0x77c>)
    1a7e:	4b5d      	ldr	r3, [pc, #372]	; (1bf4 <usb_isr+0x780>)
    1a80:	9204      	str	r2, [sp, #16]
    1a82:	4a5d      	ldr	r2, [pc, #372]	; (1bf8 <usb_isr+0x784>)
    1a84:	9203      	str	r2, [sp, #12]
    1a86:	4e5d      	ldr	r6, [pc, #372]	; (1bfc <usb_isr+0x788>)
    1a88:	4a5d      	ldr	r2, [pc, #372]	; (1c00 <usb_isr+0x78c>)
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1a8a:	9405      	str	r4, [sp, #20]
    1a8c:	9202      	str	r2, [sp, #8]
			rx_first[i] = NULL;
    1a8e:	2500      	movs	r5, #0
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1a90:	461c      	mov	r4, r3
			p = rx_first[i];
    1a92:	f856 7b04 	ldr.w	r7, [r6], #4
			while (p) {
    1a96:	b12f      	cbz	r7, 1aa4 <usb_isr+0x630>
				n = p->next;
    1a98:	4638      	mov	r0, r7
    1a9a:	687f      	ldr	r7, [r7, #4]
				usb_free(p);
    1a9c:	f000 f9ac 	bl	1df8 <usb_free>
			while (p) {
    1aa0:	2f00      	cmp	r7, #0
    1aa2:	d1f9      	bne.n	1a98 <usb_isr+0x624>
			rx_last[i] = NULL;
    1aa4:	9b02      	ldr	r3, [sp, #8]
			rx_first[i] = NULL;
    1aa6:	f846 5c04 	str.w	r5, [r6, #-4]
			rx_last[i] = NULL;
    1aaa:	f843 5b04 	str.w	r5, [r3], #4
    1aae:	9302      	str	r3, [sp, #8]
			p = tx_first[i];
    1ab0:	9b01      	ldr	r3, [sp, #4]
    1ab2:	681f      	ldr	r7, [r3, #0]
			while (p) {
    1ab4:	b12f      	cbz	r7, 1ac2 <usb_isr+0x64e>
				n = p->next;
    1ab6:	4638      	mov	r0, r7
    1ab8:	687f      	ldr	r7, [r7, #4]
				usb_free(p);
    1aba:	f000 f99d 	bl	1df8 <usb_free>
			while (p) {
    1abe:	2f00      	cmp	r7, #0
    1ac0:	d1f9      	bne.n	1ab6 <usb_isr+0x642>
			tx_first[i] = NULL;
    1ac2:	9b01      	ldr	r3, [sp, #4]
    1ac4:	f843 5b04 	str.w	r5, [r3], #4
    1ac8:	9301      	str	r3, [sp, #4]
			tx_last[i] = NULL;
    1aca:	9b04      	ldr	r3, [sp, #16]
    1acc:	f843 5b04 	str.w	r5, [r3], #4
    1ad0:	9304      	str	r3, [sp, #16]
			usb_rx_byte_count_data[i] = 0;
    1ad2:	9b03      	ldr	r3, [sp, #12]
    1ad4:	f823 5b02 	strh.w	r5, [r3], #2
    1ad8:	9303      	str	r3, [sp, #12]
			switch (tx_state[i]) {
    1ada:	7823      	ldrb	r3, [r4, #0]
    1adc:	3b02      	subs	r3, #2
    1ade:	2b03      	cmp	r3, #3
    1ae0:	d806      	bhi.n	1af0 <usb_isr+0x67c>
    1ae2:	e8df f003 	tbb	[pc, r3]
    1ae6:	023a      	.short	0x023a
    1ae8:	023a      	.short	0x023a
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1aea:	f04f 0301 	mov.w	r3, #1
    1aee:	7023      	strb	r3, [r4, #0]
		for (i=0; i < NUM_ENDPOINTS; i++) {
    1af0:	4b44      	ldr	r3, [pc, #272]	; (1c04 <usb_isr+0x790>)
    1af2:	42b3      	cmp	r3, r6
    1af4:	f104 0401 	add.w	r4, r4, #1
    1af8:	d1cb      	bne.n	1a92 <usb_isr+0x61e>
		usb_rx_memory_needed = 0;
    1afa:	4e43      	ldr	r6, [pc, #268]	; (1c08 <usb_isr+0x794>)
    1afc:	9c05      	ldr	r4, [sp, #20]
		cfg = usb_endpoint_config_table;
    1afe:	4f43      	ldr	r7, [pc, #268]	; (1c0c <usb_isr+0x798>)
		usb_rx_memory_needed = 0;
    1b00:	2300      	movs	r3, #0
    1b02:	7033      	strb	r3, [r6, #0]
    1b04:	2504      	movs	r5, #4
			epconf = *cfg++;
    1b06:	f817 3b01 	ldrb.w	r3, [r7], #1
			*reg = epconf;
    1b0a:	4a41      	ldr	r2, [pc, #260]	; (1c10 <usb_isr+0x79c>)
    1b0c:	54ab      	strb	r3, [r5, r2]
			if (epconf & USB_ENDPT_EPRXEN) {
    1b0e:	071b      	lsls	r3, r3, #28
    1b10:	d425      	bmi.n	1b5e <usb_isr+0x6ea>
			table[index(i, TX, EVEN)].desc = 0;
    1b12:	f045 0102 	orr.w	r1, r5, #2
			table[index(i, TX, ODD)].desc = 0;
    1b16:	f045 0203 	orr.w	r2, r5, #3
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    1b1a:	3504      	adds	r5, #4
			table[index(i, TX, EVEN)].desc = 0;
    1b1c:	2300      	movs	r3, #0
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    1b1e:	2d18      	cmp	r5, #24
			table[index(i, TX, EVEN)].desc = 0;
    1b20:	f848 3031 	str.w	r3, [r8, r1, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    1b24:	f848 3032 	str.w	r3, [r8, r2, lsl #3]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    1b28:	d1ed      	bne.n	1b06 <usb_isr+0x692>
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1b2a:	4e3a      	ldr	r6, [pc, #232]	; (1c14 <usb_isr+0x7a0>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1b2c:	7820      	ldrb	r0, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1b2e:	7832      	ldrb	r2, [r6, #0]
    1b30:	f042 0502 	orr.w	r5, r2, #2
    1b34:	eb08 0cc5 	add.w	ip, r8, r5, lsl #3
	ep0_tx_data_toggle ^= 1;
    1b38:	f080 0701 	eor.w	r7, r0, #1
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1b3c:	f8cc 3004 	str.w	r3, [ip, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1b40:	2800      	cmp	r0, #0
    1b42:	d14b      	bne.n	1bdc <usb_isr+0x768>
    1b44:	2388      	movs	r3, #136	; 0x88
	ep0_tx_bdt_bank ^= 1;
    1b46:	f082 0201 	eor.w	r2, r2, #1
	ep0_tx_data_toggle ^= 1;
    1b4a:	7027      	strb	r7, [r4, #0]
	ep0_tx_bdt_bank ^= 1;
    1b4c:	7032      	strb	r2, [r6, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1b4e:	f848 3035 	str.w	r3, [r8, r5, lsl #3]
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    1b52:	2301      	movs	r3, #1
    1b54:	f889 3094 	strb.w	r3, [r9, #148]	; 0x94
		break;
    1b58:	e51f      	b.n	159a <usb_isr+0x126>
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    1b5a:	7025      	strb	r5, [r4, #0]
				break;
    1b5c:	e7c8      	b.n	1af0 <usb_isr+0x67c>
				p = usb_malloc();
    1b5e:	f000 f92b 	bl	1db8 <usb_malloc>
				if (p) {
    1b62:	b310      	cbz	r0, 1baa <usb_isr+0x736>
					table[index(i, RX, EVEN)].addr = p->buf;
    1b64:	eb08 03c5 	add.w	r3, r8, r5, lsl #3
    1b68:	3008      	adds	r0, #8
    1b6a:	6058      	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    1b6c:	f848 b035 	str.w	fp, [r8, r5, lsl #3]
				p = usb_malloc();
    1b70:	f000 f922 	bl	1db8 <usb_malloc>
				if (p) {
    1b74:	b188      	cbz	r0, 1b9a <usb_isr+0x726>
					table[index(i, RX, ODD)].addr = p->buf;
    1b76:	f045 0301 	orr.w	r3, r5, #1
    1b7a:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
    1b7e:	3008      	adds	r0, #8
    1b80:	6050      	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    1b82:	f848 a033 	str.w	sl, [r8, r3, lsl #3]
    1b86:	e7c4      	b.n	1b12 <usb_isr+0x69e>
		reply_buffer[0] = 0;
    1b88:	4b23      	ldr	r3, [pc, #140]	; (1c18 <usb_isr+0x7a4>)
    1b8a:	2200      	movs	r2, #0
    1b8c:	801a      	strh	r2, [r3, #0]
		datalen = 2;
    1b8e:	2202      	movs	r2, #2
		break;
    1b90:	e5b1      	b.n	16f6 <usb_isr+0x282>
	if (datalen == 0 && size < EP0_SIZE) return;
    1b92:	283f      	cmp	r0, #63	; 0x3f
    1b94:	f63f ae9e 	bhi.w	18d4 <usb_isr+0x460>
    1b98:	e5db      	b.n	1752 <usb_isr+0x2de>
					usb_rx_memory_needed++;
    1b9a:	7833      	ldrb	r3, [r6, #0]
    1b9c:	3301      	adds	r3, #1
    1b9e:	7033      	strb	r3, [r6, #0]
					table[index(i, RX, ODD)].desc = 0;
    1ba0:	f045 0301 	orr.w	r3, r5, #1
    1ba4:	f848 0033 	str.w	r0, [r8, r3, lsl #3]
					usb_rx_memory_needed++;
    1ba8:	e7b3      	b.n	1b12 <usb_isr+0x69e>
					usb_rx_memory_needed++;
    1baa:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, EVEN)].desc = 0;
    1bac:	f848 0035 	str.w	r0, [r8, r5, lsl #3]
					usb_rx_memory_needed++;
    1bb0:	3301      	adds	r3, #1
    1bb2:	7033      	strb	r3, [r6, #0]
    1bb4:	e7dc      	b.n	1b70 <usb_isr+0x6fc>
			if (buf[0] == 0xA9 && buf[1] == 0x45 && buf[2] == 0xC2 && buf[3] == 0x6B) {
    1bb6:	786a      	ldrb	r2, [r5, #1]
    1bb8:	2a45      	cmp	r2, #69	; 0x45
    1bba:	f47f ae9b 	bne.w	18f4 <usb_isr+0x480>
    1bbe:	78aa      	ldrb	r2, [r5, #2]
    1bc0:	2ac2      	cmp	r2, #194	; 0xc2
    1bc2:	f47f ae97 	bne.w	18f4 <usb_isr+0x480>
    1bc6:	78ea      	ldrb	r2, [r5, #3]
    1bc8:	2a6b      	cmp	r2, #107	; 0x6b
    1bca:	f47f ae93 	bne.w	18f4 <usb_isr+0x480>
				usb_reboot_timer = 5;
    1bce:	4a13      	ldr	r2, [pc, #76]	; (1c1c <usb_isr+0x7a8>)
    1bd0:	2005      	movs	r0, #5
    1bd2:	7010      	strb	r0, [r2, #0]
    1bd4:	e691      	b.n	18fa <usb_isr+0x486>
		datalen = 2;
    1bd6:	2202      	movs	r2, #2
    1bd8:	e58d      	b.n	16f6 <usb_isr+0x282>
	__asm__ volatile("bkpt");
    1bda:	be00      	bkpt	0x0000
	ep0_tx_data_toggle ^= 1;
    1bdc:	7027      	strb	r7, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1bde:	23c8      	movs	r3, #200	; 0xc8
	ep0_tx_bdt_bank ^= 1;
    1be0:	f082 0701 	eor.w	r7, r2, #1
    1be4:	7037      	strb	r7, [r6, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1be6:	f848 3035 	str.w	r3, [r8, r5, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;
    1bea:	e5b2      	b.n	1752 <usb_isr+0x2de>
    1bec:	1fff0cb4 	.word	0x1fff0cb4
    1bf0:	1fff0cc8 	.word	0x1fff0cc8
    1bf4:	1fff0cdc 	.word	0x1fff0cdc
    1bf8:	1fff0ce4 	.word	0x1fff0ce4
    1bfc:	1fff0c84 	.word	0x1fff0c84
    1c00:	1fff0c98 	.word	0x1fff0c98
    1c04:	1fff0c98 	.word	0x1fff0c98
    1c08:	1fff0cee 	.word	0x1fff0cee
    1c0c:	00002864 	.word	0x00002864
    1c10:	400720c0 	.word	0x400720c0
    1c14:	1fff0c74 	.word	0x1fff0c74
    1c18:	1fff0c7c 	.word	0x1fff0c7c
    1c1c:	1fff0ce2 	.word	0x1fff0ce2

00001c20 <usb_init>:



void usb_init(void)
{
    1c20:	b510      	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    1c22:	f000 fb93 	bl	234c <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    1c26:	2300      	movs	r3, #0
    1c28:	4a1e      	ldr	r2, [pc, #120]	; (1ca4 <usb_init+0x84>)
		table[i].desc = 0;
    1c2a:	4619      	mov	r1, r3
    1c2c:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
		table[i].addr = 0;
    1c30:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    1c34:	3301      	adds	r3, #1
    1c36:	2b18      	cmp	r3, #24
		table[i].addr = 0;
    1c38:	6041      	str	r1, [r0, #4]
	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    1c3a:	d1f7      	bne.n	1c2c <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    1c3c:	481a      	ldr	r0, [pc, #104]	; (1ca8 <usb_init+0x88>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    1c3e:	4c1b      	ldr	r4, [pc, #108]	; (1cac <usb_init+0x8c>)
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    1c40:	6b43      	ldr	r3, [r0, #52]	; 0x34
    1c42:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    1c46:	6343      	str	r3, [r0, #52]	; 0x34
	MPU_RGDAAC0 |= 0x03000000;
    1c48:	f8d4 0800 	ldr.w	r0, [r4, #2048]	; 0x800
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    1c4c:	4b18      	ldr	r3, [pc, #96]	; (1cb0 <usb_init+0x90>)
	MPU_RGDAAC0 |= 0x03000000;
    1c4e:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
    1c52:	f8c4 0800 	str.w	r0, [r4, #2048]	; 0x800
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    1c56:	f3c2 2c07 	ubfx	ip, r2, #8, #8
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    1c5a:	f3c2 4407 	ubfx	r4, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    1c5e:	0e12      	lsrs	r2, r2, #24
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    1c60:	f883 c09c 	strb.w	ip, [r3, #156]	; 0x9c
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    1c64:	f883 40b0 	strb.w	r4, [r3, #176]	; 0xb0
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    1c68:	f883 20b4 	strb.w	r2, [r3, #180]	; 0xb4

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    1c6c:	4a11      	ldr	r2, [pc, #68]	; (1cb4 <usb_init+0x94>)
	USB0_ISTAT = 0xFF;
    1c6e:	20ff      	movs	r0, #255	; 0xff
	USB0_CTL = USB_CTL_USBENSOFEN;
    1c70:	f04f 0c01 	mov.w	ip, #1
	USB0_ISTAT = 0xFF;
    1c74:	f883 0080 	strb.w	r0, [r3, #128]	; 0x80
	USB0_ERRSTAT = 0xFF;
    1c78:	f883 0088 	strb.w	r0, [r3, #136]	; 0x88
	USB0_OTGISTAT = 0xFF;
    1c7c:	7418      	strb	r0, [r3, #16]
	USB0_CTL = USB_CTL_USBENSOFEN;
    1c7e:	f883 c094 	strb.w	ip, [r3, #148]	; 0x94
	USB0_USBCTRL = 0;
    1c82:	7011      	strb	r1, [r2, #0]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    1c84:	490c      	ldr	r1, [pc, #48]	; (1cb8 <usb_init+0x98>)
	USB0_INTEN = USB_INTEN_USBRSTEN;
    1c86:	f883 c084 	strb.w	ip, [r3, #132]	; 0x84
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    1c8a:	2070      	movs	r0, #112	; 0x70
    1c8c:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    1c90:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    1c94:	f44f 1000 	mov.w	r0, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    1c98:	2310      	movs	r3, #16
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    1c9a:	f8c1 0104 	str.w	r0, [r1, #260]	; 0x104
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    1c9e:	7213      	strb	r3, [r2, #8]
}
    1ca0:	bd10      	pop	{r4, pc}
    1ca2:	bf00      	nop
    1ca4:	1fff0000 	.word	0x1fff0000
    1ca8:	40048000 	.word	0x40048000
    1cac:	4000d000 	.word	0x4000d000
    1cb0:	40072000 	.word	0x40072000
    1cb4:	40072100 	.word	0x40072100
    1cb8:	e000e400 	.word	0xe000e400

00001cbc <FlightSimClass::FlightSimClass()>:



FlightSimClass::FlightSimClass()
{
}
    1cbc:	4770      	bx	lr
    1cbe:	bf00      	nop

00001cc0 <usb_flightsim_flush_callback>:
// This gets called from usb_isr when a USB start token arrives.
// If we have a packet to transmit AND transmission isn't disabled 
// by tx_noautoflush, we fill it up with zeros and send it out 
// to USB
void usb_flightsim_flush_callback(void)
{
    1cc0:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush || !tx_packet || tx_packet->index == 0) return;
    1cc2:	4b0e      	ldr	r3, [pc, #56]	; (1cfc <usb_flightsim_flush_callback+0x3c>)
    1cc4:	781b      	ldrb	r3, [r3, #0]
    1cc6:	b9bb      	cbnz	r3, 1cf8 <usb_flightsim_flush_callback+0x38>
    1cc8:	4d0d      	ldr	r5, [pc, #52]	; (1d00 <usb_flightsim_flush_callback+0x40>)
    1cca:	682c      	ldr	r4, [r5, #0]
    1ccc:	b1a4      	cbz	r4, 1cf8 <usb_flightsim_flush_callback+0x38>
    1cce:	8862      	ldrh	r2, [r4, #2]
    1cd0:	b192      	cbz	r2, 1cf8 <usb_flightsim_flush_callback+0x38>
	for (int i=tx_packet->index; i < FLIGHTSIM_TX_SIZE; i++) {
    1cd2:	2a3f      	cmp	r2, #63	; 0x3f
    1cd4:	d808      	bhi.n	1ce8 <usb_flightsim_flush_callback+0x28>
		tx_packet->buf[i] = 0;
    1cd6:	f102 0008 	add.w	r0, r2, #8
    1cda:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    1cde:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
    1ce2:	4420      	add	r0, r4
    1ce4:	f000 fb6a 	bl	23bc <memset>
	}
	tx_packet->len = FLIGHTSIM_TX_SIZE;
    1ce8:	2340      	movs	r3, #64	; 0x40
    1cea:	8023      	strh	r3, [r4, #0]
	usb_tx(FLIGHTSIM_TX_ENDPOINT, tx_packet);
    1cec:	4621      	mov	r1, r4
    1cee:	2003      	movs	r0, #3
    1cf0:	f7ff fb7c 	bl	13ec <usb_tx>
	tx_packet = NULL;
    1cf4:	2300      	movs	r3, #0
    1cf6:	602b      	str	r3, [r5, #0]
}
    1cf8:	bd38      	pop	{r3, r4, r5, pc}
    1cfa:	bf00      	nop
    1cfc:	1fff0cef 	.word	0x1fff0cef
    1d00:	1fff0cf0 	.word	0x1fff0cf0

00001d04 <_GLOBAL__sub_I__ZN16FlightSimCommand5firstE>:
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d04:	4a04      	ldr	r2, [pc, #16]	; (1d18 <_GLOBAL__sub_I__ZN16FlightSimCommand5firstE+0x14>)
class elapsedMillis
{
private:
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
    1d06:	4b05      	ldr	r3, [pc, #20]	; (1d1c <_GLOBAL__sub_I__ZN16FlightSimCommand5firstE+0x18>)
    1d08:	6812      	ldr	r2, [r2, #0]
}
    1d0a:	b082      	sub	sp, #8
    1d0c:	9201      	str	r2, [sp, #4]
	return ret;
    1d0e:	9a01      	ldr	r2, [sp, #4]
    1d10:	601a      	str	r2, [r3, #0]
    1d12:	b002      	add	sp, #8
    1d14:	4770      	bx	lr
    1d16:	bf00      	nop
    1d18:	1fff0bf0 	.word	0x1fff0bf0
    1d1c:	1fff0cf4 	.word	0x1fff0cf4

00001d20 <usb_seremu_class::peek()>:
        virtual int peek() { return usb_seremu_peekchar(); }
    1d20:	f000 b8be 	b.w	1ea0 <usb_seremu_peekchar>

00001d24 <usb_seremu_class::read()>:
        virtual int read() { return usb_seremu_getchar(); }
    1d24:	f000 b890 	b.w	1e48 <usb_seremu_getchar>

00001d28 <usb_seremu_class::available()>:
        virtual int available() { return usb_seremu_available(); }
    1d28:	f000 b8d8 	b.w	1edc <usb_seremu_available>

00001d2c <usb_seremu_class::flush()>:
        virtual void flush() { usb_seremu_flush_output(); }
    1d2c:	f000 b9c0 	b.w	20b0 <usb_seremu_flush_output>

00001d30 <usb_seremu_class::availableForWrite()>:
	virtual int availableForWrite() { return usb_seremu_write_buffer_free(); }
    1d30:	f000 b99a 	b.w	2068 <usb_seremu_write_buffer_free>

00001d34 <usb_seremu_class::write(unsigned char const*, unsigned int)>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
    1d34:	4608      	mov	r0, r1
    1d36:	4611      	mov	r1, r2
    1d38:	f000 b904 	b.w	1f44 <usb_seremu_write>

00001d3c <usb_seremu_class::write(unsigned char)>:
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
    1d3c:	4608      	mov	r0, r1
    1d3e:	f000 b985 	b.w	204c <usb_seremu_putchar>
    1d42:	bf00      	nop

00001d44 <_GLOBAL__sub_I_FlightSim>:
#ifdef RAWHID_INTERFACE
usb_rawhid_class RawHID;
#endif

#ifdef FLIGHTSIM_INTERFACE
FlightSimClass FlightSim;
    1d44:	4801      	ldr	r0, [pc, #4]	; (1d4c <_GLOBAL__sub_I_FlightSim+0x8>)
    1d46:	f7ff bfb9 	b.w	1cbc <FlightSimClass::FlightSimClass()>
    1d4a:	bf00      	nop
    1d4c:	1fff0cf8 	.word	0x1fff0cf8

00001d50 <usb_joystick_send>:
#endif



int usb_joystick_send(void)
{
    1d50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        usb_packet_t *tx_packet;

	//serial_print("send");
	//serial_print("\n");
        while (1) {
                if (!usb_configuration) {
    1d52:	4e16      	ldr	r6, [pc, #88]	; (1dac <usb_joystick_send+0x5c>)
    1d54:	7833      	ldrb	r3, [r6, #0]
    1d56:	b333      	cbz	r3, 1da6 <usb_joystick_send+0x56>
    1d58:	4f15      	ldr	r7, [pc, #84]	; (1db0 <usb_joystick_send+0x60>)
    1d5a:	f645 1489 	movw	r4, #22921	; 0x5989
    1d5e:	e007      	b.n	1d70 <usb_joystick_send+0x20>
                }
                if (usb_tx_packet_count(JOYSTICK_ENDPOINT) < TX_PACKET_LIMIT) {
                        tx_packet = usb_malloc();
                        if (tx_packet) break;
                }
                if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    1d60:	3c01      	subs	r4, #1
    1d62:	d01e      	beq.n	1da2 <usb_joystick_send+0x52>
    1d64:	783b      	ldrb	r3, [r7, #0]
    1d66:	b9e3      	cbnz	r3, 1da2 <usb_joystick_send+0x52>
                        transmit_previous_timeout = 1;
			//serial_print("error2\n");
                        return -1;
                }
                yield();
    1d68:	f000 f9e6 	bl	2138 <yield>
                if (!usb_configuration) {
    1d6c:	7833      	ldrb	r3, [r6, #0]
    1d6e:	b1d3      	cbz	r3, 1da6 <usb_joystick_send+0x56>
                if (usb_tx_packet_count(JOYSTICK_ENDPOINT) < TX_PACKET_LIMIT) {
    1d70:	2005      	movs	r0, #5
    1d72:	f7ff fae3 	bl	133c <usb_tx_packet_count>
    1d76:	2802      	cmp	r0, #2
    1d78:	d8f2      	bhi.n	1d60 <usb_joystick_send+0x10>
                        tx_packet = usb_malloc();
    1d7a:	f000 f81d 	bl	1db8 <usb_malloc>
                        if (tx_packet) break;
    1d7e:	4605      	mov	r5, r0
    1d80:	2800      	cmp	r0, #0
    1d82:	d0ed      	beq.n	1d60 <usb_joystick_send+0x10>
        }
	transmit_previous_timeout = 0;
	memcpy(tx_packet->buf, usb_joystick_data, JOYSTICK_SIZE);
    1d84:	260c      	movs	r6, #12
	transmit_previous_timeout = 0;
    1d86:	2400      	movs	r4, #0
	memcpy(tx_packet->buf, usb_joystick_data, JOYSTICK_SIZE);
    1d88:	4632      	mov	r2, r6
    1d8a:	490a      	ldr	r1, [pc, #40]	; (1db4 <usb_joystick_send+0x64>)
	transmit_previous_timeout = 0;
    1d8c:	703c      	strb	r4, [r7, #0]
	memcpy(tx_packet->buf, usb_joystick_data, JOYSTICK_SIZE);
    1d8e:	3008      	adds	r0, #8
    1d90:	f7ff f880 	bl	e94 <memcpy>
        tx_packet->len = JOYSTICK_SIZE;
    1d94:	802e      	strh	r6, [r5, #0]
        usb_tx(JOYSTICK_ENDPOINT, tx_packet);
    1d96:	4629      	mov	r1, r5
    1d98:	2005      	movs	r0, #5
    1d9a:	f7ff fb27 	bl	13ec <usb_tx>
	//serial_print("ok\n");
        return 0;
    1d9e:	4620      	mov	r0, r4
}
    1da0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                        transmit_previous_timeout = 1;
    1da2:	2301      	movs	r3, #1
    1da4:	703b      	strb	r3, [r7, #0]
                        return -1;
    1da6:	f04f 30ff 	mov.w	r0, #4294967295
}
    1daa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1dac:	1fff0ce1 	.word	0x1fff0ce1
    1db0:	1fff0cfa 	.word	0x1fff0cfa
    1db4:	1fff0cfc 	.word	0x1fff0cfc

00001db8 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    1db8:	b672      	cpsid	i
	avail = usb_buffer_available;
    1dba:	490d      	ldr	r1, [pc, #52]	; (1df0 <usb_malloc+0x38>)
    1dbc:	680b      	ldr	r3, [r1, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    1dbe:	fab3 f083 	clz	r0, r3
	if (n >= NUM_USB_BUFFERS) {
    1dc2:	2813      	cmp	r0, #19
    1dc4:	dc10      	bgt.n	1de8 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    1dc6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    1dca:	40c2      	lsrs	r2, r0
    1dcc:	ea23 0302 	bic.w	r3, r3, r2
    1dd0:	600b      	str	r3, [r1, #0]
	__enable_irq();
    1dd2:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    1dd4:	4a07      	ldr	r2, [pc, #28]	; (1df4 <usb_malloc+0x3c>)
    1dd6:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    1dda:	00c1      	lsls	r1, r0, #3
    1ddc:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    1de0:	2300      	movs	r3, #0
    1de2:	5053      	str	r3, [r2, r1]
	*(uint32_t *)(p + 4) = 0;
    1de4:	6043      	str	r3, [r0, #4]
	return (usb_packet_t *)p;
}
    1de6:	4770      	bx	lr
		__enable_irq();
    1de8:	b662      	cpsie	i
		return NULL;
    1dea:	2000      	movs	r0, #0
    1dec:	4770      	bx	lr
    1dee:	bf00      	nop
    1df0:	1fff09c8 	.word	0x1fff09c8
    1df4:	1fff0398 	.word	0x1fff0398

00001df8 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    1df8:	4b0e      	ldr	r3, [pc, #56]	; (1e34 <usb_free+0x3c>)
    1dfa:	1ac3      	subs	r3, r0, r3
	if (n >= NUM_USB_BUFFERS) return;
    1dfc:	f5b3 6fb4 	cmp.w	r3, #1440	; 0x5a0
    1e00:	d210      	bcs.n	1e24 <usb_free+0x2c>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    1e02:	4a0d      	ldr	r2, [pc, #52]	; (1e38 <usb_free+0x40>)
    1e04:	7812      	ldrb	r2, [r2, #0]
    1e06:	b972      	cbnz	r2, 1e26 <usb_free+0x2e>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    1e08:	b672      	cpsid	i
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    1e0a:	4a0c      	ldr	r2, [pc, #48]	; (1e3c <usb_free+0x44>)
	usb_buffer_available |= mask;
    1e0c:	490c      	ldr	r1, [pc, #48]	; (1e40 <usb_free+0x48>)
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    1e0e:	fba2 2303 	umull	r2, r3, r2, r3
	usb_buffer_available |= mask;
    1e12:	6808      	ldr	r0, [r1, #0]
	mask = (0x80000000 >> n);
    1e14:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    1e18:	091b      	lsrs	r3, r3, #4
	mask = (0x80000000 >> n);
    1e1a:	fa22 f303 	lsr.w	r3, r2, r3
	usb_buffer_available |= mask;
    1e1e:	4303      	orrs	r3, r0
    1e20:	600b      	str	r3, [r1, #0]
	__enable_irq();
    1e22:	b662      	cpsie	i

	//serial_print("free:");
	//serial_phex32((int)p);
	//serial_print("\n");
}
    1e24:	4770      	bx	lr
	if (usb_rx_memory_needed && usb_configuration) {
    1e26:	4a07      	ldr	r2, [pc, #28]	; (1e44 <usb_free+0x4c>)
    1e28:	7812      	ldrb	r2, [r2, #0]
    1e2a:	2a00      	cmp	r2, #0
    1e2c:	d0ec      	beq.n	1e08 <usb_free+0x10>
		usb_rx_memory(p);
    1e2e:	f7ff ba9b 	b.w	1368 <usb_rx_memory>
    1e32:	bf00      	nop
    1e34:	1fff0398 	.word	0x1fff0398
    1e38:	1fff0cee 	.word	0x1fff0cee
    1e3c:	38e38e39 	.word	0x38e38e39
    1e40:	1fff09c8 	.word	0x1fff09c8
    1e44:	1fff0ce1 	.word	0x1fff0ce1

00001e48 <usb_seremu_getchar>:
#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */


// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
    1e48:	b570      	push	{r4, r5, r6, lr}
	unsigned int i;
	int c;

	while (1) {
		if (!usb_configuration) return -1;
    1e4a:	4e13      	ldr	r6, [pc, #76]	; (1e98 <usb_seremu_getchar+0x50>)
    1e4c:	7833      	ldrb	r3, [r6, #0]
    1e4e:	b18b      	cbz	r3, 1e74 <usb_seremu_getchar+0x2c>
		if (!rx_packet) rx_packet = usb_rx(SEREMU_RX_ENDPOINT);
    1e50:	4d12      	ldr	r5, [pc, #72]	; (1e9c <usb_seremu_getchar+0x54>)
    1e52:	6828      	ldr	r0, [r5, #0]
    1e54:	b140      	cbz	r0, 1e68 <usb_seremu_getchar+0x20>
		if (!rx_packet) return -1;
		i = rx_packet->index;
    1e56:	8843      	ldrh	r3, [r0, #2]
		c = rx_packet->buf[i++];
    1e58:	18c2      	adds	r2, r0, r3
    1e5a:	7a14      	ldrb	r4, [r2, #8]
		if (c) {
    1e5c:	b974      	cbnz	r4, 1e7c <usb_seremu_getchar+0x34>
			} else {
				rx_packet->index = i;
			}
			return c;
		}
		usb_free(rx_packet);
    1e5e:	f7ff ffcb 	bl	1df8 <usb_free>
		if (!usb_configuration) return -1;
    1e62:	7833      	ldrb	r3, [r6, #0]
		rx_packet = NULL;
    1e64:	602c      	str	r4, [r5, #0]
		if (!usb_configuration) return -1;
    1e66:	b12b      	cbz	r3, 1e74 <usb_seremu_getchar+0x2c>
		if (!rx_packet) rx_packet = usb_rx(SEREMU_RX_ENDPOINT);
    1e68:	2002      	movs	r0, #2
    1e6a:	f7ff fa47 	bl	12fc <usb_rx>
    1e6e:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    1e70:	2800      	cmp	r0, #0
    1e72:	d1f0      	bne.n	1e56 <usb_seremu_getchar+0xe>
		if (!usb_configuration) return -1;
    1e74:	f04f 34ff 	mov.w	r4, #4294967295
	}
}
    1e78:	4620      	mov	r0, r4
    1e7a:	bd70      	pop	{r4, r5, r6, pc}
			if (i >= rx_packet->len) {
    1e7c:	8802      	ldrh	r2, [r0, #0]
		c = rx_packet->buf[i++];
    1e7e:	3301      	adds	r3, #1
			if (i >= rx_packet->len) {
    1e80:	429a      	cmp	r2, r3
    1e82:	d902      	bls.n	1e8a <usb_seremu_getchar+0x42>
				rx_packet->index = i;
    1e84:	8043      	strh	r3, [r0, #2]
}
    1e86:	4620      	mov	r0, r4
    1e88:	bd70      	pop	{r4, r5, r6, pc}
				usb_free(rx_packet);
    1e8a:	f7ff ffb5 	bl	1df8 <usb_free>
				rx_packet = NULL;
    1e8e:	2300      	movs	r3, #0
    1e90:	602b      	str	r3, [r5, #0]
}
    1e92:	4620      	mov	r0, r4
    1e94:	bd70      	pop	{r4, r5, r6, pc}
    1e96:	bf00      	nop
    1e98:	1fff0ce1 	.word	0x1fff0ce1
    1e9c:	1fff0d08 	.word	0x1fff0d08

00001ea0 <usb_seremu_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
    1ea0:	b570      	push	{r4, r5, r6, lr}
	int c;

	while (1) {
		if (!usb_configuration) return -1;
    1ea2:	4e0c      	ldr	r6, [pc, #48]	; (1ed4 <usb_seremu_peekchar+0x34>)
    1ea4:	7833      	ldrb	r3, [r6, #0]
    1ea6:	b18b      	cbz	r3, 1ecc <usb_seremu_peekchar+0x2c>
		if (!rx_packet) rx_packet = usb_rx(SEREMU_RX_ENDPOINT);
    1ea8:	4d0b      	ldr	r5, [pc, #44]	; (1ed8 <usb_seremu_peekchar+0x38>)
    1eaa:	6828      	ldr	r0, [r5, #0]
    1eac:	b140      	cbz	r0, 1ec0 <usb_seremu_peekchar+0x20>
		if (!rx_packet) return -1;
		c = rx_packet->buf[rx_packet->index];
    1eae:	8843      	ldrh	r3, [r0, #2]
    1eb0:	4403      	add	r3, r0
    1eb2:	7a1c      	ldrb	r4, [r3, #8]
		if (c) return c;
    1eb4:	b964      	cbnz	r4, 1ed0 <usb_seremu_peekchar+0x30>
		usb_free(rx_packet);
    1eb6:	f7ff ff9f 	bl	1df8 <usb_free>
		if (!usb_configuration) return -1;
    1eba:	7833      	ldrb	r3, [r6, #0]
		rx_packet = NULL;
    1ebc:	602c      	str	r4, [r5, #0]
		if (!usb_configuration) return -1;
    1ebe:	b12b      	cbz	r3, 1ecc <usb_seremu_peekchar+0x2c>
		if (!rx_packet) rx_packet = usb_rx(SEREMU_RX_ENDPOINT);
    1ec0:	2002      	movs	r0, #2
    1ec2:	f7ff fa1b 	bl	12fc <usb_rx>
    1ec6:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    1ec8:	2800      	cmp	r0, #0
    1eca:	d1f0      	bne.n	1eae <usb_seremu_peekchar+0xe>
		if (!usb_configuration) return -1;
    1ecc:	f04f 34ff 	mov.w	r4, #4294967295
	}
}
    1ed0:	4620      	mov	r0, r4
    1ed2:	bd70      	pop	{r4, r5, r6, pc}
    1ed4:	1fff0ce1 	.word	0x1fff0ce1
    1ed8:	1fff0d08 	.word	0x1fff0d08

00001edc <usb_seremu_available>:

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
    1edc:	b538      	push	{r3, r4, r5, lr}
	int i, len, count;

	if (!rx_packet) {
    1ede:	4d17      	ldr	r5, [pc, #92]	; (1f3c <usb_seremu_available+0x60>)
    1ee0:	682c      	ldr	r4, [r5, #0]
    1ee2:	b1cc      	cbz	r4, 1f18 <usb_seremu_available+0x3c>
		if (!rx_packet) {
			yield();
			return 0;
		}
	}
	len = rx_packet->len;
    1ee4:	8823      	ldrh	r3, [r4, #0]
	i = rx_packet->index;
    1ee6:	8861      	ldrh	r1, [r4, #2]
	count = 0;
	for (i = rx_packet->index; i < len; i++) {
    1ee8:	428b      	cmp	r3, r1
    1eea:	d90c      	bls.n	1f06 <usb_seremu_available+0x2a>
    1eec:	1dca      	adds	r2, r1, #7
    1eee:	1a58      	subs	r0, r3, r1
    1ef0:	4422      	add	r2, r4
	count = 0;
    1ef2:	2300      	movs	r3, #0
    1ef4:	e002      	b.n	1efc <usb_seremu_available+0x20>
		if (rx_packet->buf[i] == 0) break;
		count++;
    1ef6:	3301      	adds	r3, #1
	for (i = rx_packet->index; i < len; i++) {
    1ef8:	4283      	cmp	r3, r0
    1efa:	d00c      	beq.n	1f16 <usb_seremu_available+0x3a>
		if (rx_packet->buf[i] == 0) break;
    1efc:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    1f00:	2900      	cmp	r1, #0
    1f02:	d1f8      	bne.n	1ef6 <usb_seremu_available+0x1a>
	}
	if (count == 0) {
    1f04:	b9bb      	cbnz	r3, 1f36 <usb_seremu_available+0x5a>
		usb_free(rx_packet);
    1f06:	4620      	mov	r0, r4
		rx_packet = NULL;
    1f08:	2400      	movs	r4, #0
		usb_free(rx_packet);
    1f0a:	f7ff ff75 	bl	1df8 <usb_free>
		rx_packet = NULL;
    1f0e:	602c      	str	r4, [r5, #0]
		yield();
    1f10:	f000 f912 	bl	2138 <yield>
    1f14:	4620      	mov	r0, r4
	}
	return count;
}
    1f16:	bd38      	pop	{r3, r4, r5, pc}
		if (usb_configuration) rx_packet = usb_rx(SEREMU_RX_ENDPOINT);
    1f18:	4b09      	ldr	r3, [pc, #36]	; (1f40 <usb_seremu_available+0x64>)
    1f1a:	781b      	ldrb	r3, [r3, #0]
    1f1c:	b91b      	cbnz	r3, 1f26 <usb_seremu_available+0x4a>
			yield();
    1f1e:	f000 f90b 	bl	2138 <yield>
			return 0;
    1f22:	2000      	movs	r0, #0
}
    1f24:	bd38      	pop	{r3, r4, r5, pc}
		if (usb_configuration) rx_packet = usb_rx(SEREMU_RX_ENDPOINT);
    1f26:	2002      	movs	r0, #2
    1f28:	f7ff f9e8 	bl	12fc <usb_rx>
    1f2c:	4604      	mov	r4, r0
    1f2e:	6028      	str	r0, [r5, #0]
		if (!rx_packet) {
    1f30:	2800      	cmp	r0, #0
    1f32:	d1d7      	bne.n	1ee4 <usb_seremu_available+0x8>
    1f34:	e7f3      	b.n	1f1e <usb_seremu_available+0x42>
    1f36:	4618      	mov	r0, r3
}
    1f38:	bd38      	pop	{r3, r4, r5, pc}
    1f3a:	bf00      	nop
    1f3c:	1fff0d08 	.word	0x1fff0d08
    1f40:	1fff0ce1 	.word	0x1fff0ce1

00001f44 <usb_seremu_write>:
	return usb_seremu_write(&c, 1);
}


int usb_seremu_write(const void *buffer, uint32_t size)
{
    1f44:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    1f48:	4d3b      	ldr	r5, [pc, #236]	; (2038 <usb_seremu_write+0xf4>)
    1f4a:	2201      	movs	r2, #1
    1f4c:	702a      	strb	r2, [r5, #0]
	while (size > 0) {
    1f4e:	b381      	cbz	r1, 1fb2 <usb_seremu_write+0x6e>
    1f50:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 2044 <usb_seremu_write+0x100>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    1f54:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 2048 <usb_seremu_write+0x104>
    1f58:	4f38      	ldr	r7, [pc, #224]	; (203c <usb_seremu_write+0xf8>)
    1f5a:	4683      	mov	fp, r0
    1f5c:	460e      	mov	r6, r1
		if (!tx_packet) {
    1f5e:	f8d9 0000 	ldr.w	r0, [r9]
    1f62:	2800      	cmp	r0, #0
    1f64:	d037      	beq.n	1fd6 <usb_seremu_write+0x92>
				yield();
				tx_noautoflush = 1;
			}
		}
		transmit_previous_timeout = 0;
		len = SEREMU_TX_SIZE - tx_packet->index;
    1f66:	f8b0 e002 	ldrh.w	lr, [r0, #2]
    1f6a:	f1ce 0c40 	rsb	ip, lr, #64	; 0x40
    1f6e:	45b4      	cmp	ip, r6
    1f70:	bf28      	it	cs
    1f72:	46b4      	movcs	ip, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    1f74:	eb0e 040c 	add.w	r4, lr, ip
		transmit_previous_timeout = 0;
    1f78:	2200      	movs	r2, #0
		tx_packet->index += len;
    1f7a:	b2a4      	uxth	r4, r4
		transmit_previous_timeout = 0;
    1f7c:	703a      	strb	r2, [r7, #0]
		tx_packet->index += len;
    1f7e:	8044      	strh	r4, [r0, #2]
		dest = tx_packet->buf + tx_packet->index;
    1f80:	f100 0208 	add.w	r2, r0, #8
		size -= len;
    1f84:	eba6 060c 	sub.w	r6, r6, ip
		while (len-- > 0) *dest++ = *src++;
    1f88:	f1bc 0f00 	cmp.w	ip, #0
    1f8c:	d00a      	beq.n	1fa4 <usb_seremu_write+0x60>
    1f8e:	f10e 3eff 	add.w	lr, lr, #4294967295
    1f92:	4472      	add	r2, lr
    1f94:	44dc      	add	ip, fp
    1f96:	f81b 4b01 	ldrb.w	r4, [fp], #1
    1f9a:	f802 4f01 	strb.w	r4, [r2, #1]!
    1f9e:	45dc      	cmp	ip, fp
    1fa0:	d1f9      	bne.n	1f96 <usb_seremu_write+0x52>
		if (tx_packet->index < SEREMU_TX_SIZE) {
    1fa2:	8844      	ldrh	r4, [r0, #2]
    1fa4:	2c3f      	cmp	r4, #63	; 0x3f
    1fa6:	d808      	bhi.n	1fba <usb_seremu_write+0x76>
			usb_seremu_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    1fa8:	4b25      	ldr	r3, [pc, #148]	; (2040 <usb_seremu_write+0xfc>)
    1faa:	2205      	movs	r2, #5
    1fac:	701a      	strb	r2, [r3, #0]
	while (size > 0) {
    1fae:	2e00      	cmp	r6, #0
    1fb0:	d1d5      	bne.n	1f5e <usb_seremu_write+0x1a>
			usb_seremu_transmit_flush_timer = 0;
			usb_tx(SEREMU_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
	}
	tx_noautoflush = 0;
    1fb2:	2000      	movs	r0, #0
    1fb4:	7028      	strb	r0, [r5, #0]
	return 0;
#endif
}
    1fb6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			usb_seremu_transmit_flush_timer = 0;
    1fba:	4b21      	ldr	r3, [pc, #132]	; (2040 <usb_seremu_write+0xfc>)
			tx_packet->len = SEREMU_TX_SIZE;
    1fbc:	2240      	movs	r2, #64	; 0x40
    1fbe:	8002      	strh	r2, [r0, #0]
			usb_seremu_transmit_flush_timer = 0;
    1fc0:	2400      	movs	r4, #0
			usb_tx(SEREMU_TX_ENDPOINT, tx_packet);
    1fc2:	4601      	mov	r1, r0
    1fc4:	2001      	movs	r0, #1
			usb_seremu_transmit_flush_timer = 0;
    1fc6:	701c      	strb	r4, [r3, #0]
			usb_tx(SEREMU_TX_ENDPOINT, tx_packet);
    1fc8:	f7ff fa10 	bl	13ec <usb_tx>
			tx_packet = NULL;
    1fcc:	f8c9 4000 	str.w	r4, [r9]
	while (size > 0) {
    1fd0:	2e00      	cmp	r6, #0
    1fd2:	d1c4      	bne.n	1f5e <usb_seremu_write+0x1a>
    1fd4:	e7ed      	b.n	1fb2 <usb_seremu_write+0x6e>
				if (!usb_configuration) {
    1fd6:	f89a 2000 	ldrb.w	r2, [sl]
    1fda:	b33a      	cbz	r2, 202c <usb_seremu_write+0xe8>
    1fdc:	f645 1489 	movw	r4, #22921	; 0x5989
				if (usb_tx_packet_count(SEREMU_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    1fe0:	f04f 0801 	mov.w	r8, #1
    1fe4:	e00b      	b.n	1ffe <usb_seremu_write+0xba>
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    1fe6:	3c01      	subs	r4, #1
    1fe8:	d018      	beq.n	201c <usb_seremu_write+0xd8>
    1fea:	783a      	ldrb	r2, [r7, #0]
    1fec:	b9b2      	cbnz	r2, 201c <usb_seremu_write+0xd8>
				tx_noautoflush = 0;
    1fee:	702a      	strb	r2, [r5, #0]
				yield();
    1ff0:	f000 f8a2 	bl	2138 <yield>
				tx_noautoflush = 1;
    1ff4:	f885 8000 	strb.w	r8, [r5]
				if (!usb_configuration) {
    1ff8:	f89a 2000 	ldrb.w	r2, [sl]
    1ffc:	b1b2      	cbz	r2, 202c <usb_seremu_write+0xe8>
				if (usb_tx_packet_count(SEREMU_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    1ffe:	2001      	movs	r0, #1
    2000:	f7ff f99c 	bl	133c <usb_tx_packet_count>
    2004:	2805      	cmp	r0, #5
    2006:	d8ee      	bhi.n	1fe6 <usb_seremu_write+0xa2>
					tx_noautoflush = 1;
    2008:	f885 8000 	strb.w	r8, [r5]
					tx_packet = usb_malloc();
    200c:	f7ff fed4 	bl	1db8 <usb_malloc>
    2010:	f8c9 0000 	str.w	r0, [r9]
					if (tx_packet) break;
    2014:	2800      	cmp	r0, #0
    2016:	d1a6      	bne.n	1f66 <usb_seremu_write+0x22>
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    2018:	3c01      	subs	r4, #1
    201a:	d1e6      	bne.n	1fea <usb_seremu_write+0xa6>
					transmit_previous_timeout = 1;
    201c:	2201      	movs	r2, #1
					tx_noautoflush = 0;
    201e:	2300      	movs	r3, #0
					transmit_previous_timeout = 1;
    2020:	703a      	strb	r2, [r7, #0]
					tx_noautoflush = 0;
    2022:	702b      	strb	r3, [r5, #0]
					return -1;
    2024:	f04f 30ff 	mov.w	r0, #4294967295
}
    2028:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					tx_noautoflush = 0;
    202c:	2300      	movs	r3, #0
    202e:	702b      	strb	r3, [r5, #0]
					return -1;
    2030:	f04f 30ff 	mov.w	r0, #4294967295
}
    2034:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2038:	1fff0d0d 	.word	0x1fff0d0d
    203c:	1fff0d0c 	.word	0x1fff0d0c
    2040:	1fff0d15 	.word	0x1fff0d15
    2044:	1fff0d10 	.word	0x1fff0d10
    2048:	1fff0ce1 	.word	0x1fff0ce1

0000204c <usb_seremu_putchar>:
{
    204c:	b500      	push	{lr}
    204e:	b083      	sub	sp, #12
    2050:	4603      	mov	r3, r0
	return usb_seremu_write(&c, 1);
    2052:	2101      	movs	r1, #1
    2054:	f10d 0007 	add.w	r0, sp, #7
{
    2058:	f88d 3007 	strb.w	r3, [sp, #7]
	return usb_seremu_write(&c, 1);
    205c:	f7ff ff72 	bl	1f44 <usb_seremu_write>
}
    2060:	b003      	add	sp, #12
    2062:	f85d fb04 	ldr.w	pc, [sp], #4
    2066:	bf00      	nop

00002068 <usb_seremu_write_buffer_free>:

int usb_seremu_write_buffer_free(void)
{
    2068:	b538      	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    206a:	4d0e      	ldr	r5, [pc, #56]	; (20a4 <usb_seremu_write_buffer_free+0x3c>)
	tx_noautoflush = 1;
    206c:	4c0e      	ldr	r4, [pc, #56]	; (20a8 <usb_seremu_write_buffer_free+0x40>)
	if (!tx_packet) {
    206e:	682b      	ldr	r3, [r5, #0]
	tx_noautoflush = 1;
    2070:	2001      	movs	r0, #1
    2072:	7020      	strb	r0, [r4, #0]
	if (!tx_packet) {
    2074:	b12b      	cbz	r3, 2082 <usb_seremu_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = SEREMU_TX_SIZE - tx_packet->index;
    2076:	8858      	ldrh	r0, [r3, #2]
	tx_noautoflush = 0;
    2078:	2300      	movs	r3, #0
	len = SEREMU_TX_SIZE - tx_packet->index;
    207a:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	tx_noautoflush = 0;
    207e:	7023      	strb	r3, [r4, #0]
	return len;
}
    2080:	bd38      	pop	{r3, r4, r5, pc}
		if (!usb_configuration ||
    2082:	4b0a      	ldr	r3, [pc, #40]	; (20ac <usb_seremu_write_buffer_free+0x44>)
    2084:	781b      	ldrb	r3, [r3, #0]
    2086:	b913      	cbnz	r3, 208e <usb_seremu_write_buffer_free+0x26>
			tx_noautoflush = 0;
    2088:	2000      	movs	r0, #0
    208a:	7020      	strb	r0, [r4, #0]
}
    208c:	bd38      	pop	{r3, r4, r5, pc}
		  usb_tx_packet_count(SEREMU_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    208e:	f7ff f955 	bl	133c <usb_tx_packet_count>
		if (!usb_configuration ||
    2092:	2805      	cmp	r0, #5
    2094:	d8f8      	bhi.n	2088 <usb_seremu_write_buffer_free+0x20>
		  (tx_packet = usb_malloc()) == NULL) {
    2096:	f7ff fe8f 	bl	1db8 <usb_malloc>
    209a:	4603      	mov	r3, r0
    209c:	6028      	str	r0, [r5, #0]
		  usb_tx_packet_count(SEREMU_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    209e:	2800      	cmp	r0, #0
    20a0:	d1e9      	bne.n	2076 <usb_seremu_write_buffer_free+0xe>
    20a2:	e7f1      	b.n	2088 <usb_seremu_write_buffer_free+0x20>
    20a4:	1fff0d10 	.word	0x1fff0d10
    20a8:	1fff0d0d 	.word	0x1fff0d0d
    20ac:	1fff0ce1 	.word	0x1fff0ce1

000020b0 <usb_seremu_flush_output>:

void usb_seremu_flush_output(void)
{
    20b0:	b538      	push	{r3, r4, r5, lr}
	int i;

	if (!usb_configuration) return;
    20b2:	4b0e      	ldr	r3, [pc, #56]	; (20ec <usb_seremu_flush_output+0x3c>)
    20b4:	781b      	ldrb	r3, [r3, #0]
    20b6:	b1c3      	cbz	r3, 20ea <usb_seremu_flush_output+0x3a>
	//serial_print("usb_serial_flush_output\n");
	if (tx_packet && tx_packet->index > 0) {
    20b8:	4d0d      	ldr	r5, [pc, #52]	; (20f0 <usb_seremu_flush_output+0x40>)
    20ba:	682c      	ldr	r4, [r5, #0]
    20bc:	b1ac      	cbz	r4, 20ea <usb_seremu_flush_output+0x3a>
    20be:	8862      	ldrh	r2, [r4, #2]
    20c0:	b19a      	cbz	r2, 20ea <usb_seremu_flush_output+0x3a>
		usb_seremu_transmit_flush_timer = 0;
    20c2:	4b0c      	ldr	r3, [pc, #48]	; (20f4 <usb_seremu_flush_output+0x44>)
    20c4:	2100      	movs	r1, #0
		for (i = tx_packet->index; i < SEREMU_TX_SIZE; i++) {
    20c6:	2a3f      	cmp	r2, #63	; 0x3f
		usb_seremu_transmit_flush_timer = 0;
    20c8:	7019      	strb	r1, [r3, #0]
		for (i = tx_packet->index; i < SEREMU_TX_SIZE; i++) {
    20ca:	d806      	bhi.n	20da <usb_seremu_flush_output+0x2a>
			tx_packet->buf[i] = 0;
    20cc:	f102 0008 	add.w	r0, r2, #8
    20d0:	4420      	add	r0, r4
    20d2:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
    20d6:	f000 f971 	bl	23bc <memset>
		}
		tx_packet->len = SEREMU_TX_SIZE;
    20da:	2340      	movs	r3, #64	; 0x40
    20dc:	8023      	strh	r3, [r4, #0]
		usb_tx(SEREMU_TX_ENDPOINT, tx_packet);
    20de:	4621      	mov	r1, r4
    20e0:	2001      	movs	r0, #1
    20e2:	f7ff f983 	bl	13ec <usb_tx>
		tx_packet = NULL;
    20e6:	2300      	movs	r3, #0
    20e8:	602b      	str	r3, [r5, #0]
	}
	// while (usb_tx_byte_count(SEREMU_TX_ENDPOINT) > 0) ; // wait
}
    20ea:	bd38      	pop	{r3, r4, r5, pc}
    20ec:	1fff0ce1 	.word	0x1fff0ce1
    20f0:	1fff0d10 	.word	0x1fff0d10
    20f4:	1fff0d15 	.word	0x1fff0d15

000020f8 <usb_seremu_flush_callback>:

void usb_seremu_flush_callback(void)
{
    20f8:	b538      	push	{r3, r4, r5, lr}
	int i;
	//serial_print("C");
	if (tx_noautoflush) return;
    20fa:	4b0d      	ldr	r3, [pc, #52]	; (2130 <usb_seremu_flush_callback+0x38>)
    20fc:	781b      	ldrb	r3, [r3, #0]
    20fe:	b9ab      	cbnz	r3, 212c <usb_seremu_flush_callback+0x34>
	//serial_print("usb_flush_callback \n");
	for (i = tx_packet->index; i < SEREMU_TX_SIZE; i++) {
    2100:	4d0c      	ldr	r5, [pc, #48]	; (2134 <usb_seremu_flush_callback+0x3c>)
    2102:	682c      	ldr	r4, [r5, #0]
    2104:	8862      	ldrh	r2, [r4, #2]
    2106:	2a3f      	cmp	r2, #63	; 0x3f
    2108:	d808      	bhi.n	211c <usb_seremu_flush_callback+0x24>
		tx_packet->buf[i] = 0;
    210a:	f102 0008 	add.w	r0, r2, #8
    210e:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    2112:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
    2116:	4420      	add	r0, r4
    2118:	f000 f950 	bl	23bc <memset>
	}
	tx_packet->len = SEREMU_TX_SIZE;
    211c:	2340      	movs	r3, #64	; 0x40
    211e:	8023      	strh	r3, [r4, #0]
	usb_tx(SEREMU_TX_ENDPOINT, tx_packet);
    2120:	4621      	mov	r1, r4
    2122:	2001      	movs	r0, #1
    2124:	f7ff f962 	bl	13ec <usb_tx>
	tx_packet = NULL;
    2128:	2300      	movs	r3, #0
    212a:	602b      	str	r3, [r5, #0]
	//serial_print("usb_flush_callback end\n");
}
    212c:	bd38      	pop	{r3, r4, r5, pc}
    212e:	bf00      	nop
    2130:	1fff0d0d 	.word	0x1fff0d0d
    2134:	1fff0d10 	.word	0x1fff0d10

00002138 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    2138:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    213c:	4e32      	ldr	r6, [pc, #200]	; (2208 <yield+0xd0>)
    213e:	7833      	ldrb	r3, [r6, #0]
    2140:	b163      	cbz	r3, 215c <yield+0x24>
	if (running) return; // TODO: does this need to be atomic?
    2142:	4f32      	ldr	r7, [pc, #200]	; (220c <yield+0xd4>)
    2144:	783a      	ldrb	r2, [r7, #0]
    2146:	b94a      	cbnz	r2, 215c <yield+0x24>
	running = 1;
    2148:	2201      	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    214a:	07d9      	lsls	r1, r3, #31
	running = 1;
    214c:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    214e:	d443      	bmi.n	21d8 <yield+0xa0>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    2150:	079a      	lsls	r2, r3, #30
    2152:	d426      	bmi.n	21a2 <yield+0x6a>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    2154:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    2156:	075b      	lsls	r3, r3, #29
	running = 0;
    2158:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    215a:	d401      	bmi.n	2160 <yield+0x28>
	
};
    215c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    2160:	4b2b      	ldr	r3, [pc, #172]	; (2210 <yield+0xd8>)
    2162:	681a      	ldr	r2, [r3, #0]
    2164:	2a00      	cmp	r2, #0
    2166:	d0f9      	beq.n	215c <yield+0x24>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    2168:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    216c:	2a00      	cmp	r2, #0
    216e:	d1f5      	bne.n	215c <yield+0x24>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2170:	f3ef 8510 	mrs	r5, PRIMASK
		__disable_irq();
    2174:	b672      	cpsid	i
		EventResponder *first = firstYield;
    2176:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    2178:	2800      	cmp	r0, #0
    217a:	d03a      	beq.n	21f2 <yield+0xba>
		if (runningFromYield) {
    217c:	4c25      	ldr	r4, [pc, #148]	; (2214 <yield+0xdc>)
    217e:	7821      	ldrb	r1, [r4, #0]
    2180:	2900      	cmp	r1, #0
    2182:	d136      	bne.n	21f2 <yield+0xba>
		firstYield = first->_next;
    2184:	6942      	ldr	r2, [r0, #20]
    2186:	601a      	str	r2, [r3, #0]
		runningFromYield = true;
    2188:	2301      	movs	r3, #1
    218a:	7023      	strb	r3, [r4, #0]
		if (firstYield) {
    218c:	2a00      	cmp	r2, #0
    218e:	d037      	beq.n	2200 <yield+0xc8>
			firstYield->_prev = nullptr;
    2190:	6191      	str	r1, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2192:	b905      	cbnz	r5, 2196 <yield+0x5e>
    2194:	b662      	cpsie	i
		first->_triggered = false;
    2196:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    2198:	6883      	ldr	r3, [r0, #8]
		first->_triggered = false;
    219a:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    219c:	4798      	blx	r3
		runningFromYield = false;
    219e:	7025      	strb	r5, [r4, #0]
    21a0:	e7dc      	b.n	215c <yield+0x24>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    21a2:	f8df 807c 	ldr.w	r8, [pc, #124]	; 2220 <yield+0xe8>
    21a6:	f898 2000 	ldrb.w	r2, [r8]
    21aa:	2a00      	cmp	r2, #0
    21ac:	d0d2      	beq.n	2154 <yield+0x1c>
    21ae:	2500      	movs	r5, #0
    21b0:	f8df 9070 	ldr.w	r9, [pc, #112]	; 2224 <yield+0xec>
    21b4:	462b      	mov	r3, r5
			s_serials_with_serial_events[i]->doYieldCode();
    21b6:	f859 4023 	ldr.w	r4, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    21ba:	6823      	ldr	r3, [r4, #0]
    21bc:	4620      	mov	r0, r4
    21be:	691b      	ldr	r3, [r3, #16]
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    21c0:	3501      	adds	r5, #1
		if (available()) (*_serialEvent)();
    21c2:	4798      	blx	r3
    21c4:	b108      	cbz	r0, 21ca <yield+0x92>
    21c6:	6923      	ldr	r3, [r4, #16]
    21c8:	4798      	blx	r3
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    21ca:	f898 2000 	ldrb.w	r2, [r8]
    21ce:	b2eb      	uxtb	r3, r5
    21d0:	429a      	cmp	r2, r3
    21d2:	d8f0      	bhi.n	21b6 <yield+0x7e>
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    21d4:	7833      	ldrb	r3, [r6, #0]
    21d6:	e7bd      	b.n	2154 <yield+0x1c>
        virtual int available() { return usb_seremu_available(); }
    21d8:	f7ff fe80 	bl	1edc <usb_seremu_available>
		if (Serial.available()) serialEvent();
    21dc:	b968      	cbnz	r0, 21fa <yield+0xc2>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    21de:	4b0e      	ldr	r3, [pc, #56]	; (2218 <yield+0xe0>)
    21e0:	781b      	ldrb	r3, [r3, #0]
    21e2:	b90b      	cbnz	r3, 21e8 <yield+0xb0>
    21e4:	7833      	ldrb	r3, [r6, #0]
    21e6:	e7b3      	b.n	2150 <yield+0x18>
    21e8:	7833      	ldrb	r3, [r6, #0]
    21ea:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    21ee:	7033      	strb	r3, [r6, #0]
    21f0:	e7ae      	b.n	2150 <yield+0x18>
		if (doit) __enable_irq();
    21f2:	2d00      	cmp	r5, #0
    21f4:	d1b2      	bne.n	215c <yield+0x24>
    21f6:	b662      	cpsie	i
    21f8:	e7b0      	b.n	215c <yield+0x24>
		if (Serial.available()) serialEvent();
    21fa:	f000 f8a5 	bl	2348 <serialEvent()>
    21fe:	e7ee      	b.n	21de <yield+0xa6>
			lastYield = nullptr;
    2200:	4b06      	ldr	r3, [pc, #24]	; (221c <yield+0xe4>)
    2202:	601a      	str	r2, [r3, #0]
    2204:	e7c5      	b.n	2192 <yield+0x5a>
    2206:	bf00      	nop
    2208:	1fff09cc 	.word	0x1fff09cc
    220c:	1fff0d16 	.word	0x1fff0d16
    2210:	1fff0d18 	.word	0x1fff0d18
    2214:	1fff0d24 	.word	0x1fff0d24
    2218:	000027c4 	.word	0x000027c4
    221c:	1fff0d28 	.word	0x1fff0d28
    2220:	1fff0d44 	.word	0x1fff0d44
    2224:	1fff0d2c 	.word	0x1fff0d2c

00002228 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    2228:	b570      	push	{r4, r5, r6, lr}
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    222a:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    222e:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2230:	4c0c      	ldr	r4, [pc, #48]	; (2264 <EventResponder::runFromInterrupt()+0x3c>)
    2232:	6820      	ldr	r0, [r4, #0]
		if (first) {
    2234:	b180      	cbz	r0, 2258 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    2236:	4e0c      	ldr	r6, [pc, #48]	; (2268 <EventResponder::runFromInterrupt()+0x40>)
				firstInterrupt->_prev = nullptr;
    2238:	2500      	movs	r5, #0
			firstInterrupt = first->_next;
    223a:	6943      	ldr	r3, [r0, #20]
    223c:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    223e:	b173      	cbz	r3, 225e <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    2240:	619d      	str	r5, [r3, #24]
		if (doit) __enable_irq();
    2242:	b902      	cbnz	r2, 2246 <EventResponder::runFromInterrupt()+0x1e>
    2244:	b662      	cpsie	i
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
    2246:	6883      	ldr	r3, [r0, #8]
			first->_triggered = false;
    2248:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    224a:	4798      	blx	r3
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    224c:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    2250:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    2252:	6820      	ldr	r0, [r4, #0]
		if (first) {
    2254:	2800      	cmp	r0, #0
    2256:	d1f0      	bne.n	223a <EventResponder::runFromInterrupt()+0x12>
		if (doit) __enable_irq();
    2258:	b902      	cbnz	r2, 225c <EventResponder::runFromInterrupt()+0x34>
    225a:	b662      	cpsie	i
		} else {
			enableInterrupts(irq);
			break;
		}
	}
}
    225c:	bd70      	pop	{r4, r5, r6, pc}
				lastInterrupt = nullptr;
    225e:	6033      	str	r3, [r6, #0]
    2260:	e7ef      	b.n	2242 <EventResponder::runFromInterrupt()+0x1a>
    2262:	bf00      	nop
    2264:	1fff0d20 	.word	0x1fff0d20
    2268:	1fff0d1c 	.word	0x1fff0d1c

0000226c <pendablesrvreq_isr>:
	EventResponder::runFromInterrupt();
    226c:	f7ff bfdc 	b.w	2228 <EventResponder::runFromInterrupt()>

00002270 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    2270:	4a02      	ldr	r2, [pc, #8]	; (227c <systick_isr+0xc>)
    2272:	6813      	ldr	r3, [r2, #0]
    2274:	3301      	adds	r3, #1
    2276:	6013      	str	r3, [r2, #0]
}
    2278:	4770      	bx	lr
    227a:	bf00      	nop
    227c:	1fff0bf0 	.word	0x1fff0bf0

00002280 <analog_init>:
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    2280:	4b2a      	ldr	r3, [pc, #168]	; (232c <analog_init+0xac>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    2282:	4a2b      	ldr	r2, [pc, #172]	; (2330 <analog_init+0xb0>)
	VREF_TRM = 0x60;
    2284:	2060      	movs	r0, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    2286:	21e1      	movs	r1, #225	; 0xe1
	VREF_TRM = 0x60;
    2288:	7018      	strb	r0, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    228a:	7059      	strb	r1, [r3, #1]
	if (analog_config_bits == 8) {
    228c:	7813      	ldrb	r3, [r2, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    228e:	4829      	ldr	r0, [pc, #164]	; (2334 <analog_init+0xb4>)
	if (analog_config_bits == 8) {
    2290:	2b08      	cmp	r3, #8
    2292:	d034      	beq.n	22fe <analog_init+0x7e>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    2294:	2b0a      	cmp	r3, #10
    2296:	d020      	beq.n	22da <analog_init+0x5a>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    2298:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    229a:	4b27      	ldr	r3, [pc, #156]	; (2338 <analog_init+0xb8>)
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    229c:	bf0c      	ite	eq
    229e:	2135      	moveq	r1, #53	; 0x35
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    22a0:	215d      	movne	r1, #93	; 0x5d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    22a2:	2212      	movs	r2, #18
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    22a4:	6081      	str	r1, [r0, #8]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    22a6:	60c2      	str	r2, [r0, #12]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    22a8:	6099      	str	r1, [r3, #8]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    22aa:	60da      	str	r2, [r3, #12]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    22ac:	4b23      	ldr	r3, [pc, #140]	; (233c <analog_init+0xbc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    22ae:	4921      	ldr	r1, [pc, #132]	; (2334 <analog_init+0xb4>)
	if (analog_reference_internal) {
    22b0:	781b      	ldrb	r3, [r3, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    22b2:	4a21      	ldr	r2, [pc, #132]	; (2338 <analog_init+0xb8>)
	if (analog_reference_internal) {
    22b4:	b1cb      	cbz	r3, 22ea <analog_init+0x6a>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    22b6:	2301      	movs	r3, #1
    22b8:	620b      	str	r3, [r1, #32]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    22ba:	6213      	str	r3, [r2, #32]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    22bc:	4b20      	ldr	r3, [pc, #128]	; (2340 <analog_init+0xc0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    22be:	491d      	ldr	r1, [pc, #116]	; (2334 <analog_init+0xb4>)
	num = analog_num_average;
    22c0:	781b      	ldrb	r3, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    22c2:	4a1d      	ldr	r2, [pc, #116]	; (2338 <analog_init+0xb8>)
	if (num <= 1) {
    22c4:	2b01      	cmp	r3, #1
    22c6:	d913      	bls.n	22f0 <analog_init+0x70>
		#endif
	} else if (num <= 4) {
    22c8:	2b04      	cmp	r3, #4
    22ca:	d81b      	bhi.n	2304 <analog_init+0x84>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    22cc:	2384      	movs	r3, #132	; 0x84
    22ce:	624b      	str	r3, [r1, #36]	; 0x24
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    22d0:	6253      	str	r3, [r2, #36]	; 0x24
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
		#endif
	}
	calibrating = 1;
    22d2:	4b1c      	ldr	r3, [pc, #112]	; (2344 <analog_init+0xc4>)
    22d4:	2201      	movs	r2, #1
    22d6:	701a      	strb	r2, [r3, #0]
}
    22d8:	4770      	bx	lr
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    22da:	4b17      	ldr	r3, [pc, #92]	; (2338 <analog_init+0xb8>)
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    22dc:	2139      	movs	r1, #57	; 0x39
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    22de:	2213      	movs	r2, #19
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    22e0:	6081      	str	r1, [r0, #8]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    22e2:	60c2      	str	r2, [r0, #12]
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    22e4:	6099      	str	r1, [r3, #8]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    22e6:	60da      	str	r2, [r3, #12]
    22e8:	e7e0      	b.n	22ac <analog_init+0x2c>
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    22ea:	620b      	str	r3, [r1, #32]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    22ec:	6213      	str	r3, [r2, #32]
    22ee:	e7e5      	b.n	22bc <analog_init+0x3c>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    22f0:	2380      	movs	r3, #128	; 0x80
    22f2:	624b      	str	r3, [r1, #36]	; 0x24
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    22f4:	6253      	str	r3, [r2, #36]	; 0x24
	calibrating = 1;
    22f6:	4b13      	ldr	r3, [pc, #76]	; (2344 <analog_init+0xc4>)
    22f8:	2201      	movs	r2, #1
    22fa:	701a      	strb	r2, [r3, #0]
}
    22fc:	4770      	bx	lr
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    22fe:	4b0e      	ldr	r3, [pc, #56]	; (2338 <analog_init+0xb8>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    2300:	2121      	movs	r1, #33	; 0x21
    2302:	e7ec      	b.n	22de <analog_init+0x5e>
	} else if (num <= 8) {
    2304:	2b08      	cmp	r3, #8
    2306:	d806      	bhi.n	2316 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    2308:	2385      	movs	r3, #133	; 0x85
    230a:	624b      	str	r3, [r1, #36]	; 0x24
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    230c:	6253      	str	r3, [r2, #36]	; 0x24
	calibrating = 1;
    230e:	4b0d      	ldr	r3, [pc, #52]	; (2344 <analog_init+0xc4>)
    2310:	2201      	movs	r2, #1
    2312:	701a      	strb	r2, [r3, #0]
}
    2314:	4770      	bx	lr
	} else if (num <= 16) {
    2316:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    2318:	bf94      	ite	ls
    231a:	2386      	movls	r3, #134	; 0x86
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    231c:	2387      	movhi	r3, #135	; 0x87
    231e:	624b      	str	r3, [r1, #36]	; 0x24
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    2320:	6253      	str	r3, [r2, #36]	; 0x24
	calibrating = 1;
    2322:	4b08      	ldr	r3, [pc, #32]	; (2344 <analog_init+0xc4>)
    2324:	2201      	movs	r2, #1
    2326:	701a      	strb	r2, [r3, #0]
}
    2328:	4770      	bx	lr
    232a:	bf00      	nop
    232c:	40074000 	.word	0x40074000
    2330:	1fff09cd 	.word	0x1fff09cd
    2334:	4003b000 	.word	0x4003b000
    2338:	400bb000 	.word	0x400bb000
    233c:	1fff0d45 	.word	0x1fff0d45
    2340:	1fff09ce 	.word	0x1fff09ce
    2344:	1fff0d46 	.word	0x1fff0d46

00002348 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
}
    2348:	4770      	bx	lr
    234a:	bf00      	nop

0000234c <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    234c:	b510      	push	{r4, lr}
    234e:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    2350:	b672      	cpsid	i
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    2352:	4a16      	ldr	r2, [pc, #88]	; (23ac <usb_init_serialnumber+0x60>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    2354:	4916      	ldr	r1, [pc, #88]	; (23b0 <usb_init_serialnumber+0x64>)
    2356:	6051      	str	r1, [r2, #4]
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    2358:	2070      	movs	r0, #112	; 0x70
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    235a:	2380      	movs	r3, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    235c:	7010      	strb	r0, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    235e:	7013      	strb	r3, [r2, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    2360:	7813      	ldrb	r3, [r2, #0]
    2362:	061b      	lsls	r3, r3, #24
    2364:	d5fc      	bpl.n	2360 <usb_init_serialnumber+0x14>
	num = *(uint32_t *)&FTFL_FCCOBB;
    2366:	68d0      	ldr	r0, [r2, #12]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    2368:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    236a:	4b12      	ldr	r3, [pc, #72]	; (23b4 <usb_init_serialnumber+0x68>)
    236c:	4c12      	ldr	r4, [pc, #72]	; (23b8 <usb_init_serialnumber+0x6c>)
    236e:	4298      	cmp	r0, r3
    2370:	bf38      	it	cc
    2372:	eb00 0080 	addcc.w	r0, r0, r0, lsl #2
	ultoa(num, buf, 10);
    2376:	a901      	add	r1, sp, #4
	if (num < 10000000) num = num * 10;
    2378:	bf38      	it	cc
    237a:	0040      	lslcc	r0, r0, #1
	ultoa(num, buf, 10);
    237c:	220a      	movs	r2, #10
    237e:	f7fe fe8b 	bl	1098 <ultoa>
	for (i=0; i<10; i++) {
    2382:	a901      	add	r1, sp, #4
    2384:	4620      	mov	r0, r4
    2386:	2300      	movs	r3, #0
		char c = buf[i];
    2388:	f811 2b01 	ldrb.w	r2, [r1], #1
	for (i=0; i<10; i++) {
    238c:	3301      	adds	r3, #1
		if (!c) break;
    238e:	b13a      	cbz	r2, 23a0 <usb_init_serialnumber+0x54>
	for (i=0; i<10; i++) {
    2390:	2b0a      	cmp	r3, #10
		usb_string_serial_number_default.wString[i] = c;
    2392:	f820 2f02 	strh.w	r2, [r0, #2]!
	for (i=0; i<10; i++) {
    2396:	d1f7      	bne.n	2388 <usb_init_serialnumber+0x3c>
    2398:	2316      	movs	r3, #22
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    239a:	7023      	strb	r3, [r4, #0]
}
    239c:	b004      	add	sp, #16
    239e:	bd10      	pop	{r4, pc}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    23a0:	005b      	lsls	r3, r3, #1
    23a2:	b2db      	uxtb	r3, r3
    23a4:	7023      	strb	r3, [r4, #0]
}
    23a6:	b004      	add	sp, #16
    23a8:	bd10      	pop	{r4, pc}
    23aa:	bf00      	nop
    23ac:	40020000 	.word	0x40020000
    23b0:	41070000 	.word	0x41070000
    23b4:	00989680 	.word	0x00989680
    23b8:	1fff0b34 	.word	0x1fff0b34

000023bc <memset>:
    23bc:	0783      	lsls	r3, r0, #30
    23be:	b530      	push	{r4, r5, lr}
    23c0:	d048      	beq.n	2454 <memset+0x98>
    23c2:	1e54      	subs	r4, r2, #1
    23c4:	2a00      	cmp	r2, #0
    23c6:	d03f      	beq.n	2448 <memset+0x8c>
    23c8:	b2ca      	uxtb	r2, r1
    23ca:	4603      	mov	r3, r0
    23cc:	e001      	b.n	23d2 <memset+0x16>
    23ce:	3c01      	subs	r4, #1
    23d0:	d33a      	bcc.n	2448 <memset+0x8c>
    23d2:	f803 2b01 	strb.w	r2, [r3], #1
    23d6:	079d      	lsls	r5, r3, #30
    23d8:	d1f9      	bne.n	23ce <memset+0x12>
    23da:	2c03      	cmp	r4, #3
    23dc:	d92d      	bls.n	243a <memset+0x7e>
    23de:	b2cd      	uxtb	r5, r1
    23e0:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    23e4:	2c0f      	cmp	r4, #15
    23e6:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    23ea:	d936      	bls.n	245a <memset+0x9e>
    23ec:	f1a4 0210 	sub.w	r2, r4, #16
    23f0:	f022 0c0f 	bic.w	ip, r2, #15
    23f4:	f103 0e20 	add.w	lr, r3, #32
    23f8:	44e6      	add	lr, ip
    23fa:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    23fe:	f103 0210 	add.w	r2, r3, #16
    2402:	e942 5504 	strd	r5, r5, [r2, #-16]
    2406:	e942 5502 	strd	r5, r5, [r2, #-8]
    240a:	3210      	adds	r2, #16
    240c:	4572      	cmp	r2, lr
    240e:	d1f8      	bne.n	2402 <memset+0x46>
    2410:	f10c 0201 	add.w	r2, ip, #1
    2414:	f014 0f0c 	tst.w	r4, #12
    2418:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    241c:	f004 0c0f 	and.w	ip, r4, #15
    2420:	d013      	beq.n	244a <memset+0x8e>
    2422:	f1ac 0304 	sub.w	r3, ip, #4
    2426:	f023 0303 	bic.w	r3, r3, #3
    242a:	3304      	adds	r3, #4
    242c:	4413      	add	r3, r2
    242e:	f842 5b04 	str.w	r5, [r2], #4
    2432:	4293      	cmp	r3, r2
    2434:	d1fb      	bne.n	242e <memset+0x72>
    2436:	f00c 0403 	and.w	r4, ip, #3
    243a:	b12c      	cbz	r4, 2448 <memset+0x8c>
    243c:	b2c9      	uxtb	r1, r1
    243e:	441c      	add	r4, r3
    2440:	f803 1b01 	strb.w	r1, [r3], #1
    2444:	429c      	cmp	r4, r3
    2446:	d1fb      	bne.n	2440 <memset+0x84>
    2448:	bd30      	pop	{r4, r5, pc}
    244a:	4664      	mov	r4, ip
    244c:	4613      	mov	r3, r2
    244e:	2c00      	cmp	r4, #0
    2450:	d1f4      	bne.n	243c <memset+0x80>
    2452:	e7f9      	b.n	2448 <memset+0x8c>
    2454:	4603      	mov	r3, r0
    2456:	4614      	mov	r4, r2
    2458:	e7bf      	b.n	23da <memset+0x1e>
    245a:	461a      	mov	r2, r3
    245c:	46a4      	mov	ip, r4
    245e:	e7e0      	b.n	2422 <memset+0x66>

00002460 <__libc_init_array>:
    2460:	b570      	push	{r4, r5, r6, lr}
    2462:	4e0d      	ldr	r6, [pc, #52]	; (2498 <__libc_init_array+0x38>)
    2464:	4d0d      	ldr	r5, [pc, #52]	; (249c <__libc_init_array+0x3c>)
    2466:	1b76      	subs	r6, r6, r5
    2468:	10b6      	asrs	r6, r6, #2
    246a:	d006      	beq.n	247a <__libc_init_array+0x1a>
    246c:	2400      	movs	r4, #0
    246e:	f855 3b04 	ldr.w	r3, [r5], #4
    2472:	3401      	adds	r4, #1
    2474:	4798      	blx	r3
    2476:	42a6      	cmp	r6, r4
    2478:	d1f9      	bne.n	246e <__libc_init_array+0xe>
    247a:	4e09      	ldr	r6, [pc, #36]	; (24a0 <__libc_init_array+0x40>)
    247c:	4d09      	ldr	r5, [pc, #36]	; (24a4 <__libc_init_array+0x44>)
    247e:	1b76      	subs	r6, r6, r5
    2480:	f000 f9f4 	bl	286c <_init>
    2484:	10b6      	asrs	r6, r6, #2
    2486:	d006      	beq.n	2496 <__libc_init_array+0x36>
    2488:	2400      	movs	r4, #0
    248a:	f855 3b04 	ldr.w	r3, [r5], #4
    248e:	3401      	adds	r4, #1
    2490:	4798      	blx	r3
    2492:	42a6      	cmp	r6, r4
    2494:	d1f9      	bne.n	248a <__libc_init_array+0x2a>
    2496:	bd70      	pop	{r4, r5, r6, pc}
    2498:	00002878 	.word	0x00002878
    249c:	00002878 	.word	0x00002878
    24a0:	00002888 	.word	0x00002888
    24a4:	00002878 	.word	0x00002878

000024a8 <__retarget_lock_acquire_recursive>:
    24a8:	4770      	bx	lr
    24aa:	bf00      	nop

000024ac <__retarget_lock_release_recursive>:
    24ac:	4770      	bx	lr
    24ae:	bf00      	nop

000024b0 <register_fini>:
    24b0:	4b02      	ldr	r3, [pc, #8]	; (24bc <register_fini+0xc>)
    24b2:	b113      	cbz	r3, 24ba <register_fini+0xa>
    24b4:	4802      	ldr	r0, [pc, #8]	; (24c0 <register_fini+0x10>)
    24b6:	f000 b805 	b.w	24c4 <atexit>
    24ba:	4770      	bx	lr
    24bc:	00000000 	.word	0x00000000
    24c0:	000024d1 	.word	0x000024d1

000024c4 <atexit>:
    24c4:	2300      	movs	r3, #0
    24c6:	4601      	mov	r1, r0
    24c8:	461a      	mov	r2, r3
    24ca:	4618      	mov	r0, r3
    24cc:	f000 b814 	b.w	24f8 <__register_exitproc>

000024d0 <__libc_fini_array>:
    24d0:	b538      	push	{r3, r4, r5, lr}
    24d2:	4d07      	ldr	r5, [pc, #28]	; (24f0 <__libc_fini_array+0x20>)
    24d4:	4c07      	ldr	r4, [pc, #28]	; (24f4 <__libc_fini_array+0x24>)
    24d6:	1b2c      	subs	r4, r5, r4
    24d8:	10a4      	asrs	r4, r4, #2
    24da:	d005      	beq.n	24e8 <__libc_fini_array+0x18>
    24dc:	3c01      	subs	r4, #1
    24de:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    24e2:	4798      	blx	r3
    24e4:	2c00      	cmp	r4, #0
    24e6:	d1f9      	bne.n	24dc <__libc_fini_array+0xc>
    24e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    24ec:	f000 b9cc 	b.w	2888 <__init_array_end>
	...

000024f8 <__register_exitproc>:
    24f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    24fc:	f8df a07c 	ldr.w	sl, [pc, #124]	; 257c <__register_exitproc+0x84>
    2500:	4606      	mov	r6, r0
    2502:	f8da 0000 	ldr.w	r0, [sl]
    2506:	4698      	mov	r8, r3
    2508:	460f      	mov	r7, r1
    250a:	4691      	mov	r9, r2
    250c:	f7ff ffcc 	bl	24a8 <__retarget_lock_acquire_recursive>
    2510:	4b18      	ldr	r3, [pc, #96]	; (2574 <__register_exitproc+0x7c>)
    2512:	681c      	ldr	r4, [r3, #0]
    2514:	b324      	cbz	r4, 2560 <__register_exitproc+0x68>
    2516:	6865      	ldr	r5, [r4, #4]
    2518:	2d1f      	cmp	r5, #31
    251a:	dc24      	bgt.n	2566 <__register_exitproc+0x6e>
    251c:	b95e      	cbnz	r6, 2536 <__register_exitproc+0x3e>
    251e:	1c6b      	adds	r3, r5, #1
    2520:	3502      	adds	r5, #2
    2522:	f8da 0000 	ldr.w	r0, [sl]
    2526:	6063      	str	r3, [r4, #4]
    2528:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
    252c:	f7ff ffbe 	bl	24ac <__retarget_lock_release_recursive>
    2530:	2000      	movs	r0, #0
    2532:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2536:	eb04 0185 	add.w	r1, r4, r5, lsl #2
    253a:	2301      	movs	r3, #1
    253c:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
    2540:	f8d4 2188 	ldr.w	r2, [r4, #392]	; 0x188
    2544:	40ab      	lsls	r3, r5
    2546:	431a      	orrs	r2, r3
    2548:	2e02      	cmp	r6, #2
    254a:	f8c4 2188 	str.w	r2, [r4, #392]	; 0x188
    254e:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
    2552:	d1e4      	bne.n	251e <__register_exitproc+0x26>
    2554:	f8d4 218c 	ldr.w	r2, [r4, #396]	; 0x18c
    2558:	431a      	orrs	r2, r3
    255a:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    255e:	e7de      	b.n	251e <__register_exitproc+0x26>
    2560:	4c05      	ldr	r4, [pc, #20]	; (2578 <__register_exitproc+0x80>)
    2562:	601c      	str	r4, [r3, #0]
    2564:	e7d7      	b.n	2516 <__register_exitproc+0x1e>
    2566:	f8da 0000 	ldr.w	r0, [sl]
    256a:	f7ff ff9f 	bl	24ac <__retarget_lock_release_recursive>
    256e:	f04f 30ff 	mov.w	r0, #4294967295
    2572:	e7de      	b.n	2532 <__register_exitproc+0x3a>
    2574:	1fff0d4c 	.word	0x1fff0d4c
    2578:	1fff0d50 	.word	0x1fff0d50
    257c:	1fff0b4c 	.word	0x1fff0b4c
    2580:	69676542 	.word	0x69676542
    2584:	6f43206e 	.word	0x6f43206e
    2588:	656c706d 	.word	0x656c706d
    258c:	4a206574 	.word	0x4a206574
    2590:	7473796f 	.word	0x7473796f
    2594:	206b6369 	.word	0x206b6369
    2598:	74736554 	.word	0x74736554
    259c:	ffffff00 	.word	0xffffff00

000025a0 <digital_pin_to_info_PGM>:
    25a0:	43fe0840 4004a040 43fe0844 4004a044     @..C@..@D..CD..@
    25b0:	43fe1800 4004c000 43fe0030 40049030     ...C...@0..C0..@
    25c0:	43fe0034 40049034 43fe181c 4004c01c     4..C4..@...C...@
    25d0:	43fe1810 4004c010 43fe1808 4004c008     ...C...@...C...@
    25e0:	43fe180c 4004c00c 43fe100c 4004b00c     ...C...@...C...@
    25f0:	43fe1010 4004b010 43fe1018 4004b018     ...C...@...C...@
    2600:	43fe101c 4004b01c 43fe1014 4004b014     ...C...@...C...@
    2610:	43fe1804 4004c004 43fe1000 4004b000     ...C...@...C...@
    2620:	43fe0800 4004a000 43fe0804 4004a004     ...C...@...C...@
    2630:	43fe080c 4004a00c 43fe0808 4004a008     ...C...@...C...@
    2640:	43fe1814 4004c014 43fe1818 4004c018     ...C...@...C...@
    2650:	43fe1004 4004b004 43fe1008 4004b008     ...C...@...C...@
    2660:	43fe2068 4004d068 43fe0014 40049014     h .Ch..@...C...@
    2670:	43fe0038 40049038 43fe003c 4004903c     8..C8..@<..C<..@
    2680:	43fe0040 40049040 43fe0848 4004a048     @..C@..@H..CH..@
    2690:	43fe084c 4004a04c 43fe0828 4004a028     L..CL..@(..C(..@
    26a0:	43fe082c 4004a02c 43fe2060 4004d060     ,..C,..@` .C`..@
    26b0:	43fe2064 4004d064 43fe1020 4004b020     d .Cd..@ ..C ..@
    26c0:	43fe1024 4004b024 43fe1028 4004b028     $..C$..@(..C(..@
    26d0:	43fe102c 4004b02c 43fe0044 40049044     ,..C,..@D..CD..@
    26e0:	43fe0070 40049070 43fe0074 40049074     p..Cp..@t..Ct..@
    26f0:	43fe0068 40049068 43fe0850 4004a050     h..Ch..@P..CP..@
    2700:	43fe0858 4004a058 43fe085c 4004a05c     X..CX..@\..C\..@
    2710:	43fe0854 4004a054 43fe1820 4004c020     T..CT..@ ..C ..@
    2720:	43fe1824 4004c024 43fe0810 4004a010     $..C$..@...C...@
    2730:	43fe0814 4004a014 43fe1838 4004c038     ...C...@8..C8..@
    2740:	43fe1834 4004c034 43fe1830 4004c030     4..C4..@0..C0..@
    2750:	43fe183c 4004c03c 43fe182c 4004c02c     <..C<..@,..C,..@
    2760:	43fe2028 4004d028 43fe202c 4004d02c     ( .C(..@, .C,..@
    2770:	43fe2000 4004d000 43fe2004 4004d004     . .C...@. .C...@
    2780:	43fe2008 4004d008 43fe200c 4004d00c     . .C...@. .C...@
    2790:	43fe2010 4004d010 43fe2014 4004d014     . .C...@. .C...@

000027a0 <vtable for usb_seremu_class>:
	...
    27a8:	00001d3d 00001d35 00001d31 00001d2d     =...5...1...-...
    27b8:	00001d29 00001d25 00001d21              )...%...!...

000027c4 <_serialEvent_default>:
    27c4:	ffffff00                                ....

000027c8 <usb_descriptor_list>:
    27c8:	00000100 1fff0a34 00000012 00000200     ....4...........
    27d8:	1fff09d0 00000062 00012200 1fff0abc     ....b...."......
    27e8:	00000021 00012100 1fff0a02 00000009     !....!..........
    27f8:	00022200 1fff0a64 00000055 00022100     ."..d...U....!..
    2808:	1fff0a22 00000009 00002200 1fff0a48     "........"..H...
    2818:	0000001c 00002100 1fff09e2 00000009     .....!..........
    2828:	00000300 1fff0ae0 00000000 04090301     ................
    2838:	1fff0ae4 00000000 04090302 1fff0afc     ................
    2848:	00000000 04090303 1fff0b34 00000000     ........4.......
	...

00002864 <usb_endpoint_config_table>:
    2864:	19151915 ffffff15                       ........

0000286c <_init>:
    286c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    286e:	bf00      	nop
    2870:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2872:	bc08      	pop	{r3}
    2874:	469e      	mov	lr, r3
    2876:	4770      	bx	lr

00002878 <__init_array_start>:
    2878:	000024b1 	.word	0x000024b1

0000287c <__frame_dummy_init_array_entry>:
    287c:	00000435 00001d05 00001d45              5.......E...

Disassembly of section .fini:

00002888 <_fini>:
    2888:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    288a:	bf00      	nop
